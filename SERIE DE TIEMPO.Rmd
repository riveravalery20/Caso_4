---
title: ""
subtitle:
output:
  html_document:
    theme: default
    toc: true
    toc_float: true
    toc_depth: 4
    number_sections: true
    code_folding: show
    df_print: paged
    self_contained: true
---

<style>
/* Estilo para el bot√≥n */
#global-code-toggle {
  position: fixed;
  bottom: 30px;
  right: 30px;
  z-index: 10000;
  background: linear-gradient(135deg, #430089 0%, #6b21b6 100%);
  color: white;
  border: none;
  padding: 14px 26px;
  border-radius: 10px;
  font-weight: 700;
  font-size: 15px;
  cursor: pointer;
  box-shadow: 0 4px 12px rgba(107,33,168,0.35);
  transition: all 0.3s ease;
  letter-spacing: 0.6px;
  font-family: "Times New Roman", serif;
}

#global-code-toggle:hover {
  transform: translateY(-3px);
  box-shadow: 0 6px 18px rgba(107,33,168,0.45);
}

/* Estilo para los bloques de c√≥digo */
.code-content {
  transition: all 0.4s ease;
  overflow: hidden;
}

.code-content.hidden {
  max-height: 0;
  opacity: 0;
  padding: 0 18px;
}

.code-content.visible {
  max-height: 5000px;
  opacity: 1;
  padding: 18px;
}
</style>

<!-- Bot√≥n -->
<button id="global-code-toggle">üëÅ Ocultar c√≥digo</button>

<script>
document.addEventListener("DOMContentLoaded", function() {
  const btn = document.getElementById("global-code-toggle");
  let visible = true;

  function toggleAllCode() {
    const codeBlocks = document.querySelectorAll(".code-content");

    codeBlocks.forEach(block => {
      if (visible) {
        block.classList.remove("visible");
        block.classList.add("hidden");
      } else {
        block.classList.remove("hidden");
        block.classList.add("visible");
      }
    });

    visible = !visible;
    btn.textContent = visible ? "üëÅ Ocultar c√≥digo" : "üìÑ Ver c√≥digo";
  }

  btn.addEventListener("click", toggleAllCode);
});
</script>


```{r setup, include=FALSE, cache=FALSE}
knitr::opts_chunk$set(
  echo = TRUE,
  warning = FALSE,
  message = FALSE,
  fig.align = "center",
  fig.width = 8,
  fig.height = 6,
  out.width = "100%"
)


```

```{r libraries}
library(tidyverse)
library(forecast)
library(tseries)
library(ggplot2)
library(gridExtra)
library(knitr)
library(kableExtra)
library(plotly)
library(lubridate)
library(quantmod)
library(fpp2)
library(scales)
library(viridis)
library(patchwork)
library(grid)
library(RColorBrewer)
library(dplyr)
library(gt)
```

```{r theme-professional}
# Tema personalizado elegante
theme_professional <- function() {
  theme_minimal() +
  theme(
    plot.background = element_rect(fill = "white", color = NA),
    panel.background = element_rect(fill = "#f8f9fa", color = NA),
    panel.grid.major = element_line(color = "#e2e8f0", size = 0.4),
    panel.grid.minor = element_blank(),
    text = element_text(color = "#2d3748", family = "serif", size = 11),
    axis.text = element_text(color = "#4a5568", size = 10),
    axis.title = element_text(color = "#1a365d", face = "bold", size = 12),
    plot.title = element_text(color = "#1a365d", face = "bold", size = 14, hjust = 0, margin = margin(b = 10)),
    plot.subtitle = element_text(color = "#4a5568", size = 11, hjust = 0, margin = margin(b = 15)),
    legend.background = element_rect(fill = "white", color = NA),
    legend.text = element_text(color = "#4a5568", size = 10),
    legend.title = element_text(color = "#1a365d", face = "bold", size = 10),
    legend.position = "bottom"
  )
}

theme_set(theme_professional())
```

# Introducci√≥n

Los mercados de metales preciosos constituyen componentes esenciales de la econom√≠a global cuya din√°mica responde a m√∫ltiples factores interconectados: ciclos econ√≥micos, expectativas inflacionarias, volatilidad de sistemas financieros, demanda sectorial diversificada (manufactura, electr√≥nica, automoci√≥n, joyer√≠a) y restricciones de oferta minera amplificadas por tensiones geopol√≠ticas. La interacci√≥n simult√°nea de estos elementos genera comportamientos complejos que trascienden la simple oferta y demanda, demandando enfoques anal√≠ticos rigurosos para su comprensi√≥n.

El ETF GLTR (abrdn Physical Precious Metals Basket Shares) proporciona exposici√≥n diversificada a cuatro metales preciosos‚Äîoro, plata, platino y paladio‚Äîcuya correlaci√≥n con ciclos macroecon√≥micos var√≠a seg√∫n el metal espec√≠fico y el contexto econ√≥mico prevaleciente. Esta composici√≥n equilibrada lo posiciona como indicador agregado particularmente sensible de la salud de mercados de commodities globales, funcionando simult√°neamente como proxy de demanda por activos refugio durante episodios de inestabilidad financiera severa o depreciaci√≥n acelerada de monedas fiduciarias. Su estructura respaldada por dep√≥sito f√≠sico de metales en b√≥vedas certificadas elimina riesgos de contraparte, vinculando directamente el valor del fondo a precios spot de metales subyacentes.

El an√°lisis de series temporales resulta indispensable para decodificar esta complejidad multidimensional de mercados de metales preciosos. Permite identificar tendencias estructurales de mediano y largo plazo que subyacen a fluctuaciones de corto plazo, detectar y cuantificar patrones estacionales y componentes c√≠clicos recurrentes, reconocer puntos de quiebre que se√±alan cambios significativos en condiciones de equilibrio de mercado, medir la evoluci√≥n din√°mica de volatilidad para calibraci√≥n precisa de riesgo, y generar pron√≥sticos probabil√≠sticos fundamentados que orienten decisiones de inversi√≥n y gesti√≥n de exposiciones en contextos de incertidumbre persistente.

Este tipo de an√°lisis trasciende significativamente el inter√©s puramente financiero, poseyendo implicaciones para m√∫ltiples stakeholders con responsabilidades estrat√©gicas distintas. Para inversores institucionales y de retail, la precisi√≥n predictiva sobre GLTR mejora sustancialmente estrategias de diversificaci√≥n de portafolios y cobertura de riesgos sist√©micos. Para gestores de riesgos en instituciones financieras, estos pron√≥sticos alimentan directamente modelos de p√©rdidas potenciales, pruebas de estr√©s bajo escenarios adversos, y c√°lculos de requerimientos de capital regulatorio. Para autoridades monetarias y bancos centrales, la din√°mica observable de metales preciosos proporciona se√±ales tempranas sobre presiones inflacionarias emergentes, credibilidad de pol√≠ticas monetarias implementadas, y cambios en expectativas de inversores globales respecto a estabilidad macroecon√≥mica. En s√≠ntesis, la capacidad de anticipar cambios en mercados de materias primas resulta cr√≠tica para preservar estabilidad financiera sist√©mica y prevenir crisis financieras en contextos de creciente incertidumbre global.


# Metodolog√≠a
GLTR (abrdn Physical Precious Metals Basket Shares ETF) fue seleccionado como instrumento de an√°lisis por ser un fondo que proporciona exposici√≥n diversificada a cuatro metales preciosos: oro (65%), plata (27%), platino (4%) y paladio (4%). Esta composici√≥n permite capturar din√°micas agregadas de mercados de materias primas globales. Adicionalmente, GLTR respalda sus participaciones con dep√≥sito f√≠sico de metales en b√≥vedas certificadas, elimina riesgos de contraparte, y ofrece datos diarios p√∫blicamente disponibles con alta liquidez, caracter√≠sticas esenciales para an√°lisis de series temporales robustas.‚Äã

La ventana octubre 2022 ‚Äì octubre 2025 captura la transici√≥n desde endurecimiento monetario m√°ximo (tasas a 4.0% para combatir inflaci√≥n de 40 a√±os tras invasi√≥n de Rusia a Ucrania) hacia relajaci√≥n monetaria con rally estructural de metales preciosos.
**2022:** GLTR oscila sin direcci√≥n clara ($70-95) bajo presiones contrapuestas de inflaci√≥n extrema versus tasas reales elevadas.
**2023:** Crisis bancaria (SVB, marzo) genera demanda puntual de refugio, pero se resuelve r√°pidamente. A√±o cierra plano (+2%).
**2024-2025:** Rally sostenido impulsado por expectativas de recortes de tasas, deuda p√∫blica m√°xima, riesgos geopol√≠ticos y sanciones a Rusia. GLTR sube 40% en diez meses; desempe√±o anual: 2024 (+21%), 2025 (+69%).
Aproximadamente 750-760 observaciones diarias proporciona robustez estad√≠stica para ARIMA. El per√≠odo captura cambio de r√©gimen claro, validando la serie para pron√≥stico.


**Concepto de Serie de Tiempo**

Una serie de tiempo se define como una colecci√≥n ordenada de observaciones de una misma variable registradas en instantes discretos y equiespaciados. Desde el punto de vista probabil√≠stico, puede interpretarse como una realizaci√≥n de un proceso estoc√°stico ${Yt}t‚ààZ$, donde cada $Yt$  es una variable aleatoria indexada por el tiempo. A diferencia de los datos independientes e id√©nticamente distribuidos, en las series temporales las observaciones sucesivas suelen presentar dependencia, de modo que la distribuci√≥n conjunta de $(Y_t, Y_t‚àí_1,‚Ä¶,Y_t‚àí_k)$ no puede factorizarse como producto de distribuciones marginales independientes.
La teor√≠a cl√°sica considera que una serie observada puede descomponerse en componentes deterministas y estoc√°sticos. En un esquema aditivo, se escribe:
$Yt=Tt+St+Ct+It$
donde $Tt$  representa la tendencia de largo plazo, asociada a cambios sistem√°ticos en el nivel medio de la serie; St recoge la estacionalidad, esto es, patrones que se repiten con periodicidad fija (mensual, trimestral, anual); Ct refleja el componente c√≠clico, vinculado a oscilaciones de medio y largo plazo sin periodo exactamente constante, a menudo relacionadas con ciclos econ√≥micos; e It es el componente irregular, que agrupa las fluctuaciones aleatorias no explicadas por los anteriores.
Un concepto central en la modelizaci√≥n es la estacionariedad. Una serie estacionaria en sentido d√©bil presenta media constante $E(Yt)=Œº$, varianza finita y constante $Var(Yt)=œÉ^2$ y una funci√≥n de autocovarianza $Œ≥k=Cov(Y_t,Y_t‚àí_k)$ que depende solo del desfase k, no del instante calendario. Esta propiedad permite aplicar la teor√≠a de procesos lineales y garantiza estabilidad de la estructura de dependencia en el tiempo. En la pr√°ctica, muchas series financieras en niveles, como los precios de activos, no son estacionarias y requieren transformaciones (por ejemplo, diferencias o rendimientos logar√≠tmicos) para aproximarse a procesos estacionarios antes de ser modeladas.

**Componentes Fundamentales**

$$Y_t = T_t + S_t + C_t + I_t$$

Donde cada componente representa:

- **$Y_t$**: Valor observado en el tiempo $t$
- **$T_t$**: Componente de tendencia (movimiento de largo plazo)
- **$S_t$**: Componente estacional (patrones regulares)
- **$C_t$**: Componente c√≠clico (fluctuaciones peri√≥dicas)
- **$I_t$**: Componente irregular o ruido

**Modelo ARIMA**

Dentro de los modelos lineales para series temporales, la familia ARIMA (AutoRegressive Integrated Moving Average) constituye una de las herramientas m√°s utilizadas para describir y pronosticar procesos que pueden hacerse estacionarios mediante diferenciaci√≥n. La idea fundamental es representar la serie transformada como combinaci√≥n de un componente autorregresivo y uno de medias m√≥viles, permitiendo capturar tanto la influencia de valores pasados como el efecto persistente de perturbaciones aleatorias.
En su forma general, un modelo ARIMA(p,d,q) para una serie {Yt} se expresa mediante la acci√≥n conjunta de tres operadores: el operador de rezago B, definido por BYt=Yt‚àí1; el operador de diferencia (1‚àíB)^d , aplicado d veces para eliminar tendencias estoc√°sticas; y dos polinomios en B que describen la parte autorregresiva y de medias m√≥viles. La estructura autorregresiva de orden p se recoge en la ecuaci√≥n (1):
$$yt=c+œï1yt‚àí1+œï2yt‚àí2+‚Ä¶+œïpyt‚àíp+Œµt  \  (1)$$

donde c es una constante, $œïi$  son los coeficientes autorregresivos y $Œµt$ es un t√©rmino de error, usualmente modelado como ruido blanco con media cero y varianza constante.
La parte integrada del modelo se vincula al n√∫mero de diferencias necesarias para lograr estacionariedad. La primera y segunda diferencias ilustran los casos d=1 y d=2:
$$y‚Ä≤t=yt‚àíy_t‚àí_1  \ (2)$$
$$yt‚Ä≤‚Ä≤=(yt‚àíy_t‚àí_1)‚àí(y_t‚àí_1‚àíy_t‚àí_2)=yt‚àí2yt‚àí1+yt‚àí2   \  (3)$$
Por su parte, el componente de medias m√≥viles de orden q se representa en la ecuaci√≥n (4):
$$yt=c+Œµt+Œ∏1Œµt‚àí1+Œ∏2Œµt‚àí2+‚Ä¶+Œ∏qŒµt‚àíq\ (4)$$
donde $Œ∏j$ son los coeficientes de medias m√≥viles. La combinaci√≥n de las partes AR y MA para una serie ya estacionaria da lugar al modelo ARMA(p,q), cuya forma general se sintetiza en (5):
$$yt=c+œï1yt‚àí1+œï2yt‚àí2+‚ãØ+œïpyt‚àíp+Œµt+Œ∏1Œµt‚àí1+Œ∏2Œµt‚àí2+‚ãØ+Œ∏qŒµt‚àíq   \   (5)$$
Cuando el modelo se aplica sobre la serie diferenciada $d$ veces, se obtiene un ARIMA(p,d,q). As√≠, por ejemplo, un ARIMA(3,1,0) indica un proceso autorregresivo de orden 3 sobre la primera diferencia de la serie, sin componente de medias m√≥viles.
La importancia de los modelos ARIMA en predicci√≥n radica en que proporcionan un marco probabil√≠stico capaz de representar de forma expl√≠cita las autocorrelaciones presentes en los datos. Al combinar la memoria de la serie (a trav√©s de la parte autorregresiva) con la influencia de shocks pasados (a trav√©s de la parte de medias m√≥viles), permiten construir pron√≥sticos condicionados a la informaci√≥n disponible en el tiempo t y obtener expresiones para la varianza del error de predicci√≥n. Esto posibilita no solo generar valores esperados futuros, sino tambi√©n intervalos de confianza que cuantifican la incertidumbre inherente al proceso. En contextos financieros, donde variables como precios, tipos de cambio o √≠ndices muestran dependencia temporal y, con frecuencia, no estacionariedad, los modelos ARIMA se han consolidado como herramientas est√°ndar para el pron√≥stico de corto y mediano plazo.

**Metodolog√≠a de Box‚ÄìJenkins.**
La implementaci√≥n pr√°ctica de modelos ARIMA se estructura habitualmente mediante la metodolog√≠a de Box‚ÄìJenkins, que organiza el proceso de modelizaci√≥n en cuatro etapas principales: identificaci√≥n, estimaci√≥n, diagn√≥stico y predicci√≥n. Este enfoque proporciona un marco iterativo que permite seleccionar, ajustar y validar el modelo m√°s adecuado para una serie dada.

**1. Identificaci√≥n del modelo**
La etapa de identificaci√≥n tiene como objetivo determinar si la serie requiere diferenciaci√≥n para alcanzar estacionariedad y proponer valores iniciales para los √≥rdenes $p$ y $q$. En primer lugar, se eval√∫a la presencia de ra√≠z unitaria mediante pruebas como la de Dickey‚ÄìFuller aumentada, cuya hip√≥tesis nula plantea que la serie es no estacionaria. Si esta hip√≥tesis no puede rechazarse, se procede a diferenciar la serie, aplicando una o m√°s diferencias hasta que los estad√≠sticos sugieran estacionariedad en la serie transformada.
Una vez alcanzada una aproximaci√≥n razonable a la estacionariedad, se analizan la funci√≥n de autocorrelaci√≥n (ACF) y la funci√≥n de autocorrelaci√≥n parcial (PACF). Patrones de decaimiento gradual o cortes abruptos en estas funciones proporcionan informaci√≥n sobre la posible estructura autorregresiva o de medias m√≥viles subyacente. Por ejemplo, un corte claro en la PACF con ACF que decae de forma suave suele asociarse a un modelo AR, mientras que el patr√≥n inverso sugiere la presencia de un modelo MA.

**2.Estimaci√≥n de par√°metros**
Definida una especificaci√≥n preliminar ARIMA(p,d,q), la segunda etapa consiste en estimar sus par√°metros. Este ajuste se realiza habitualmente mediante el m√©todo de m√°xima verosimilitud, que busca los valores de $œïi, Œ∏j$ y de la varianza del t√©rmino de error que maximizan la probabilidad de observar la muestra disponible, bajo el supuesto de que los errores $Œµt$ son aproximadamente independientes y con distribuci√≥n normal. Los algoritmos num√©ricos empleados resuelven un problema de optimizaci√≥n no lineal y proporcionan estimadores puntuales junto con errores est√°ndar que permiten evaluar la significancia estad√≠stica de los coeficientes.

**3. Diagn√≥stico y validaci√≥n del modelo**
En la tercera etapa se analiza si el modelo ajustado describe adecuadamente la din√°mica de la serie. Para que un modelo ARIMA sea considerado adecuado, los residuos estimados $Œµt=yt‚àíyt$ deben comportarse como ruido blanco: no presentar autocorrelaci√≥n significativa, tener media aproximadamente nula y varianza constante. Estas condiciones se verifican mediante la inspecci√≥n gr√°fica de los residuos, el an√°lisis de su ACF residual y pruebas de hip√≥tesis como la de Ljung‚ÄìBox, que contrasta de manera conjunta la ausencia de autocorrelaci√≥n hasta un cierto n√∫mero de rezagos.
Adem√°s, se comparan especificaciones alternativas utilizando criterios de informaci√≥n como el AIC o el BIC, que equilibran la calidad del ajuste con la complejidad del modelo penalizando el exceso de par√°metros. Un modelo con residuos no blancos o con criterios de informaci√≥n claramente peores que otro candidato se considera inadecuado y suele descartarse o reformularse, regresando a la fase de identificaci√≥n.

**4. Predicci√≥n o pron√≥stico**
Una vez que el modelo ha superado los controles de diagn√≥stico, se utiliza para generar pron√≥sticos a diferentes horizontes. Los modelos ARIMA permiten obtener, para cada horizonte $h$, un valor pronosticado $y^t+h‚à£t$ y la varianza asociada al error de predicci√≥n, lo que facilita la construcci√≥n de intervalos de confianza que reflejan la incertidumbre creciente a medida que aumenta el horizonte temporal. Estos pron√≥sticos pueden evaluarse ex post mediante medidas como el error cuadr√°tico medio (RMSE) o el error absoluto medio (MAE), comparando valores pronosticados con realizaciones observadas en una ventana de validaci√≥n.
En el caso del ETF GLTR, la aplicaci√≥n de la metodolog√≠a Box‚ÄìJenkins permite ajustar un modelo ARIMA coherente con la estructura de dependencia temporal identificada en la serie de precios y utilizarlo como herramienta para el pron√≥stico de corto plazo, aportando una base cuantitativa s√≥lida para el an√°lisis prospectivo y la gesti√≥n del riesgo financiero.


# Descripci√≥n

--- Carga y Preparaci√≥n----

```{r data-preparation}

AccionesEX <- getSymbols("GLTR", src = "yahoo", auto.assign = FALSE, 
                         from = "2022-10-31")

names(AccionesEX)
GLTR <- AccionesEX$GLTR.Close

# Preparar dataframe para an√°lisis descriptivo
GLTR_df <- data.frame(
  Fecha = index(GLTR),
  Precio = as.numeric(GLTR),
  A√±o = year(index(GLTR)),
  Mes = month(index(GLTR), label = TRUE, abbr = FALSE),
  Dia_Semana = wday(index(GLTR), label = TRUE, abbr = FALSE)
)
```

## Descripci√≥n de la serie

**Ficha t√©cnica** 

El abrdn Physical Precious Metals Basket Shares ETF (GLTR) es un fondo cotizado en bolsa que busca replicar el comportamiento conjunto de una canasta de metales preciosos f√≠sicos, integrada principalmente por oro, plata, platino y paladio. Fue lanzado en octubre de 2010, en un contexto posterior a la crisis financiera global de 2008‚Äì2009, cuando se intensific√≥ el inter√©s de los inversionistas por activos refugio y veh√≠culos que ofrecieran exposici√≥n directa a metales sin necesidad de almacenar lingotes de forma individual.
GLTR est√° estructurado como un grantor trust respaldado por lingotes f√≠sicos, custodiados en b√≥vedas certificadas en centros financieros como Londres y Z√∫rich. Esta configuraci√≥n evita riesgos asociados a derivados y contratos de futuros, vinculando el valor del fondo directamente a los precios spot de los metales subyacentes. El activo bajo gesti√≥n asciende a aproximadamente 1.850 millones de USD, validando su relevancia y liquidez en los mercados institucionales y de retail.

```{r ficha t√©cnica-stats}
# Crear tabla comparativa estilo profesional
ficha_tecnica <- data.frame(
  Caracter√≠stica = c(
    "Nombre del ETF",
    "S√≠mbolo/Ticker",
    "Tipo de activo",
    "Activos subyacentes",
    "Composici√≥n actual",
    "Activos bajo gesti√≥n (AUM)",
    "Expense Ratio",
    "Beta (vs. S&P 500)",
    "Rango 52 semanas",
    "Precio actual (aprox)",
    "Rendimiento 2024",
    "Rendimiento YTD 2025",
    "Volumen promedio diario",
    "Bolsa de cotizaci√≥n",
    "Fecha de lanzamiento"
  ),
  Valor = c(
    "Aberdeen Standard Physical Precious Metals Basket Shares ETF",
    "GLTR",
    "ETF de metales preciosos f√≠sicos",
    "Oro, plata, paladio, platino f√≠sicos",
    "Oro: 62%, Plata: 31%, Paladio: 4%, Platino: 3%",
    "$1,850 millones USD",
    "0.60%",
    "0.21",
    "$109.20 - $171.85",
    "$168.50",
    "+20.3%",
    "+38.5% (hasta octubre)",
    "150,000 acciones",
    "NYSE Arca",
    "Octubre 2010"
  ),
  Nota = c(
    "Nombre completo del instrumento",
    "Ticker de negociaci√≥n principal",
    "Clasificaci√≥n del producto",
    "Metales f√≠sicos almacenados en b√≥vedas",
    "Distribuci√≥n basada en valores de mercado actuales",
    "Ha crecido 35% en los √∫ltimos 12 meses",
    "Competitivo dentro del sector de ETFs de metales",
    "Baja correlaci√≥n con el mercado accionario",
    "M√≠nimo hist√≥rico: $109.20 (Oct 2024)",
    "Precio de cierre m√°s reciente disponible",
    "Impulsado por rally de metales preciosos",
    "Fuerte desempe√±o por demanda de activos refugio",
    "Alta liquidez para entrada/salida",
    "Principal exchange para ETFs en EE.UU.",
    "M√°s de 15 a√±os en el mercado"
  )
)

# Formatear la tabla profesional
ficha_tecnica %>%
  kable(align = "lcl", 
        caption = "Tabla 1. FICHA T√âCNICA DEL ETF GLTR - METALES PRECIOSOS") %>%
  kable_styling(bootstrap_options = c("striped", "hover", "condensed"), 
                full_width = FALSE,
                font_size = 12) %>%
  row_spec(0, background = "#1E3A8A", color = "white", bold = TRUE) %>%
  column_spec(1, bold = TRUE, width = "25%") %>%
  column_spec(2, width = "35%") %>%
  column_spec(3, width = "40%", 
              color = "#666666") %>%
  # Resaltar valores importantes
  column_spec(2,
              color = ifelse(
                grepl("\\+[0-9]", ficha_tecnica$Valor), "#27AE60",  # Verde para rendimientos positivos
                ifelse(
                  grepl("^\\$", ficha_tecnica$Valor), "#3498DB",    # Azul para valores monetarios
                  "black"
                )
              ),
              bold = ifelse(
                grepl("\\+[0-9]|^\\$", ficha_tecnica$Valor),
                TRUE,
                FALSE
              ))
```
**Distribuci√≥n de la canasta**
```{r dona interactiva}
# Datos de composici√≥n del ETF
composition_data <- data.frame(
  Metal = c("Oro F√≠sico", "Plata F√≠sica", "Paladio F√≠sico", "Platino F√≠sico"),
  Porcentaje = c(61.77, 30.72, 4.26, 3.26),
  Valor_Mercado = c("1B", "702M", "97M", "74M")
)

# A√±adir etiquetas detalladas
composition_data <- composition_data %>%
  mutate(
    Etiqueta = paste0(
      "<b>", Metal, "</b><br>",
      Porcentaje, "%<br>",
      "(", Valor_Mercado, ")"
    ),
    # Colores met√°licos realistas
    Color = c("#FFD700", "#C0C0C0", "#B8B8B8", "#E5E4E2"),
    # Texto para hover
    HoverText = paste0(
      "<b>", Metal, "</b><br>",
      "Composici√≥n: <b>", Porcentaje, "%</b><br>",
      "Valor de mercado: <b>", Valor_Mercado, "</b><br>",
      "Aproximado en cartera:<br>",
      case_when(
        Metal == "Oro F√≠sico" ~ "60-65%",
        Metal == "Plata F√≠sica" ~ "25-30%",
        Metal == "Paladio F√≠sico" ~ "3-5%",
        Metal == "Platino F√≠sico" ~ "3-5%"
      )
    )
  )

# Crear donut chart interactivo
donut_interactive <- plot_ly(
  composition_data,
  labels = ~Metal,
  values = ~Porcentaje,
  type = 'pie',
  hole = 0.5,  # Esto crea el efecto donut
  textposition = 'outside',
  textinfo = 'label+percent',
  hoverinfo = 'text',
  text = ~HoverText,
  marker = list(
    colors = ~Color,
    line = list(color = '#FFFFFF', width = 2)
  ),
  # A√±adir texto en el centro
  domain = list(x = c(0, 1), y = c(0, 1))
) %>%
  layout(
    title = list(
      text = "<b>Composici√≥n del ETF GLTR<br>Aberdeen Standard Physical<br>Precious Metals Basket Shares</b>",
      font = list(
        size = 20,
        color = "#1E3A8A",
        family = "Arial, sans-serif"
      ),
      x = 0.5,
      y = 0.95
    ),
    showlegend = TRUE,
    legend = list(
      orientation = "v",
      x = 1.05,
      y = 0.5,
      font = list(size = 12),
      title = list(
        text = "<b>Metales</b>",
        font = list(size = 14)
      )
    ),
    # A√±adir anotaci√≥n en el centro del donut
    annotations = list(
      list(
        text = "<b>Total AUM</b><br>~$1.9B",
        x = 0.5,
        y = 0.5,
        font = list(
          size = 16,
          color = "#1E3A8A",
          family = "Arial, sans-serif"
        ),
        showarrow = FALSE
      )
    ),
    paper_bgcolor = "#F8F9FA",
    plot_bgcolor = "#F8F9FA",
    margin = list(t = 100, b = 80, l = 20, r = 150)
  )

# Mostrar donut chart
donut_interactive
```
La composici√≥n refleja que GLTR est√° dominado por oro y plata (>92 % en conjunto), mientras que platino y paladio proporcionan exposici√≥n industrial complementaria. Esta ponderaci√≥n es deliberada: oro y plata funcionan como dep√≥sitos de valor refugio, mientras que platino y paladio est√°n ligados a demanda industrial. De este modo, GLTR combina protecci√≥n contra riesgos macroecon√≥micos con exposici√≥n a fundamentales de demanda f√≠sica de metales preciosos.

### Contexto hist√≥rico.
El an√°lisis de series de tiempo requiere entender el contexto econ√≥mico que determina el comportamiento. Como ETF de metales f√≠sicos, GLTR refleja ciclos macroecon√≥micos, decisiones de bancos centrales y eventos geopol√≠ticos. Desde su lanzamiento en 2010, ha experimentado m√∫ltiples reg√≠menes: expansiones monetarias post-crisis, normalizaci√≥n, shocks geopol√≠ticos, crisis financieras y el actual rally de m√°ximos hist√≥ricos.
```{r Serie de niveles}
# Descargar datos
GLTR <- getSymbols("GLTR", src = "yahoo", auto.assign = FALSE, from = "2010-01-01")

# Preparar datos
GLTR_df <- data.frame(
  Fecha = index(GLTR),
  Precio = as.numeric(Cl(GLTR))
)

# Gr√°fico interactivo
plot_ly(GLTR_df, x = ~Fecha, y = ~Precio, type = "scatter", mode = "lines",
        line = list(color = "#1E3A8A", width = 2),
        hoverinfo = "text",
        text = ~paste("Fecha:", Fecha, "<br>Precio: $", round(Precio, 2))) %>%
  layout(
    title = "<b>ETF GLTR - Serie Hist√≥rica (2010-2025)</b>",
    xaxis = list(title = "Fecha", rangeslider = list(visible = TRUE)),
    yaxis = list(title = "Precio (USD)", tickformat = "$,.2f"),
    hovermode = "x unified"
  )
```
La trayectoria completa de GLTR durante los 15 a√±os de historia desde su creaci√≥n muestra cinco fases claramente diferenciadas. La ventana de an√°lisis (2022‚Äì2025) captura la transici√≥n cr√≠tica desde volatilidad indeterminada hacia rally s√≥lido, justificando ARIMA para modelar cambios de r√©gimen.

**Rally post-crisis y b√∫squeda de refugio (2010‚Äì2012)**
GLTR se lanza en octubre de 2010 tras la crisis financiera de 2008‚Äì2009, cuando bancos centrales implementan flexibilizaci√≥n cuantitativa (QE) masiva para estabilizar mercados. La Reserva Federal inicia programas de compra de activos sin precedentes (QE1, QE2), el Banco Central Europeo y el Banco de Jap√≥n adoptan pol√≠ticas ultra-expansivas, inyectando miles de millones de d√≥lares en liquidez al sistema financiero.‚Äã
En este contexto de expansi√≥n monetaria extrema, surge demanda masiva por metales como cobertura contra inflaci√≥n futura y depreciaci√≥n de monedas fiduciarias. Durante 2010‚Äì2012, GLTR sube de &#95‚Äì100 a ~&#115‚Äì120, reflejando el rally del oro de &#1.200 a 1.900+ USD/oz y la plata de &#18 a 48+ USD/oz en sus m√°ximos de abril de 2011. La tendencia alcista es coherente con la tesis de refugio: est√≠mulos masivos y temor inflacionario implican apreciaci√≥n de metales con pocas correcciones
```{r 2010-2012}
# Plata 2010‚Äì2012 (proxy: SLV)
silver_10_12 <- getSymbols("SLV", src = "yahoo", auto.assign = FALSE,
                           from = "2010-01-01", to = "2012-12-31")
silver_10_12_close <- Cl(silver_10_12)

silver_10_12_df <- data.frame(
  fecha  = index(silver_10_12_close),
  precio = as.numeric(silver_10_12_close)
)

g_plata_10_12 <- ggplot(silver_10_12_df, aes(x = fecha, y = precio)) +
  geom_line(color = "gray40", linewidth = 0.8) +
  labs(title = "Precio de la plata 2010‚Äì2012 (proxy: SLV)",
       subtitle = "Rally post-crisis y m√°ximos asociados a QE e inflaci√≥n esperada",
       x = "Fecha", y = "Precio de cierre (USD)") +
  theme_minimal()

g_plata_10_12_int <- ggplotly(g_plata_10_12)
g_plata_10_12_int

```
La Figura 3 muestra el comportamiento de la plata entre 2010 y 2012 (proxy SLV), con un rally acelerado hasta m√°ximos hist√≥ricos en 2011 (~$48/oz) y una posterior correcci√≥n moderada hacia finales de 2011 e inicios de 2012. Esta din√°mica es consistente con el contexto de expansi√≥n monetaria extrema y temor inflacionario posterior a la crisis de 2008‚Äì2009, en el que los metales preciosos se revalorizaron de forma pronunciada como dep√≥sitos de valor refugio. La volatilidad observada en 2011 refleja especulaci√≥n intensiva y ajustes de portafolio conforme aumentaban preocupaciones sobre sostenibilidad de precios.

**Correcci√≥n y consolidaci√≥n durante normalizaci√≥n monetaria (2013‚Äì2015)**
En 2013, la Reserva Federal anuncia el "tapering" (reducci√≥n gradual) de compras de activos y la econom√≠a estadounidense muestra recuperaci√≥n m√°s s√≥lida, aumentando expectativas de subidas futuras en tasas de inter√©s. Con tasas reales esperadas m√°s altas, el costo de oportunidad de mantener oro aumenta. Adem√°s, el d√≥lar estadounidense se fortalece, encareciendo commodities para inversionistas internacionales y presionando precios a la baja.‚Äã
GLTR cae sostenidamente desde m√°ximos de 2011‚Äì2012 a m√≠nimos cercanos a $50‚Äì60 hacia mediados de 2015. Este per√≠odo de correcci√≥n es completamente explicable por los fundamentales: normalizaci√≥n monetaria y fortalecimiento del d√≥lar.

**Recuperaci√≥n moderada bajo incertidumbre pol√≠tica (2016‚Äì2019)**
Entre 2016 y 2019, la trayectoria de GLTR es menos volatil pero a√∫n presenta repuntes puntuales asociados a episodios espec√≠ficos de incertidumbre. El Brexit en junio de 2016, la elecci√≥n de Donald Trump en noviembre de 2016, y tensiones comerciales crecientes entre Estados Unidos y China a partir de 2018 generan episodios de aversi√≥n al riesgo que benefician temporalmente al oro y otros metales refugio.
Sin embargo, estos repuntes son t√°cticos m√°s que estructurales. Las subidas de tasas realizadas por la Reserva Federal entre 2015 y 2018, junto con la fortaleza del d√≥lar, limitan que GLTR consolide ganancias sostenidas. El precio del ETF oscila entre &#65‚Äì&#85 durante este per√≠odo, formando un patr√≥n de recuperaci√≥n lenta pero vol√°til, donde cada crisis geopol√≠tica genera un pico temporal seguido por correcci√≥n cuando la tensi√≥n se disipa.

**Pandemia COVID-19 y m√°ximos hist√≥ricos (2020)**
El a√±o 2020 es un punto de inflexi√≥n cr√≠tico. En marzo de 2020, la pandemia desencadena un p√°nico financiero global sin precedentes en la era moderna. Los mercados accionarios caen m√°s de 30 % en semanas. El VIX (√≠ndice de volatilidad) alcanza m√°ximos hist√≥ricos. Los inversionistas huyen masivamente hacia activos considerados seguros.
En respuesta, y con una velocidad extraordinaria, los bancos centrales lanzan programas de est√≠mulo sin paralelo hist√≥rico:
La Reserva Federal reduce tasas a cero y relanza compra de activos ("QE infinito").
El Banco Central Europeo ampl√≠a su programa de compra de bonos.
Los gobiernos implementan paquetes fiscales masivos de miles de billones de d√≥lares.
En este contexto extremo, el oro se comporta de forma excepcional. Alcanza m√°ximos hist√≥ricos por encima de 2.000 USD/oz hacia agosto de 2020. GLTR refleja este movimiento con un rally espectacular de ~30‚Äì40 % anual.
```{r 2020}
# Descargar datos si no los tienes
GLTR <- getSymbols("GLTR", src = "yahoo", auto.assign = FALSE, from = "2020-01-01", to = "2020-12-31")

# Preparar datos para 2020
datos_2020 <- data.frame(
  Fecha = index(GLTR),
  Precio = as.numeric(Cl(GLTR))
)

# Crear gr√°fico interactivo
plot_ly(datos_2020, x = ~Fecha) %>%
  add_trace(y = ~Precio, type = 'scatter', mode = 'lines',
            line = list(color = '#1E3A8A', width = 3),
            name = 'Precio GLTR',
            hoverinfo = 'text',
            text = ~paste('<b>Fecha:</b>', Fecha, '<br><b>Precio:</b> $', round(Precio, 2))) %>%
  
  # Eventos clave
  add_trace(x = as.Date('2020-03-16'), y = ~Precio[Fecha == as.Date('2020-03-16')],
            type = 'scatter', mode = 'markers',
            marker = list(color = '#9fa0ff', size = 12, symbol = 'circle'),
            name = 'Colapso mercados',
            hoverinfo = 'text',
            text = '<b>16 Mar 2020:</b> Colapso de mercados globales<br>Fed anuncia est√≠mulos de emergencia') %>%
  
  add_trace(x = as.Date('2020-08-07'), y = ~Precio[Fecha == as.Date('2020-08-07')],
            type = 'scatter', mode = 'markers',
            marker = list(color = '#dab6fc', size = 12, symbol = 'diamond'),
            name = 'R√©cord oro',
            hoverinfo = 'text',
            text = '<b>07 Ago 2020:</b> Oro supera $2,000/oz<br>Rally hist√≥rico de metales preciosos') %>%
  
  layout(
    title = list(
      text = '<b>Comportamiento del ETF GLTR durante la Pandemia COVID-19 (2020)</b>',
      font = list(size = 18, color = '#1E3A8A', family = 'Arial'),
      y = 0.98,  # Posici√≥n vertical del t√≠tulo
      x = 0.5,   # Posici√≥n horizontal centrada
      xanchor = 'center',
      yanchor = 'top'
    ),
    xaxis = list(
      title = '<b>Fecha</b>',
      type = 'date',
      tickformat = '%b %Y',
      rangeslider = list(visible = TRUE)
    ),
    yaxis = list(
      title = '<b>Precio (USD)</b>',
      tickformat = '$.2f',
      gridcolor = 'lightgray'
    ),
    hovermode = 'x unified',
    plot_bgcolor = 'white',
    paper_bgcolor = '#F8F9FA',
    margin = list(t = 120, b = 80, l = 80, r = 40),  # Aumentado margen superior
    showlegend = TRUE,
    legend = list(
      orientation = 'h',
      x = 0.5,
      xanchor = 'center',
      y = -0.2,
      yanchor = 'top'
    )
  )
```
La serie muestra un colapso inicial agudo a mediados de marzo (cuando el precio cae a &#65‚Äì70) debido al p√°nico de liquidaci√≥n indiscriminada. Sin embargo, a partir de finales de marzo/principios de abril, comienza un rally acelerado y sostenido, con GLTR alcanzando nuevos m√°ximos de $#105+ hacia finales de a√±o. Este comportamiento es textualmente consistente con la teor√≠a: metales preciosos act√∫an como refugio en contextos de riesgo sist√©mico extremo, pero tambi√©n se benefician de la expansi√≥n monetaria ultra-expansiva que caracteriza la respuesta de los bancos centrales.

**Normalizaci√≥n post-pandemia y correcci√≥n (2021)**
En 2021, a medida que avanzan las campa√±as de vacunaci√≥n y la actividad econ√≥mica se recupera, el panorama vuelve a cambiar. Los inversionistas comienzan a rotar capital desde activos defensivos hacia activos c√≠clicos. Las expectativas de inflaci√≥n permanecen elevadas, pero ya est√°n incorporadas en los precios. Los bancos centrales comienzan a discutir p√∫blicamente la reducci√≥n de est√≠mulos ("taper talk").
El resultado es una correcci√≥n en GLTR de aproximadamente ‚Äì10 % en el a√±o. El oro retrocede desde m√°ximos de &#2.000+ a niveles cercanos a &#1.700‚Äì1.800. GLTR refleja esta din√°mica con una serie principalmente lateral con tendencia bajista moderada. Este comportamiento no es sorpresa: representa la normalizaci√≥n esperada tras un pico extremo de aversi√≥n al riesgo.

**Guerra Rusia-Ucrania, inflaci√≥n hist√≥rica y volatilidad sin precedentes (2022)**
El 24 de febrero de 2022, Rusia invade Ucrania, desencadenando la mayor crisis geopol√≠tica en Europa en 30 a√±os. El shock de oferta en energ√≠a (petr√≥leo sube de &#80 a &#120+ por barril, gas natural europeo se multiplica por 5) y alimentos (trigo, ma√≠z, aceites vegetales) dispara inflaci√≥n global a m√°ximos de 40+ a√±os: inflaci√≥n estadounidense alcanza 9.1% en junio de 2022, inflaci√≥n europea supera 10%.‚Äã
Simult√°neamente, la Reserva Federal realiza subidas de tasas hist√≥ricas bajo Jerome Powell: de pr√°cticamente 0% en marzo de 2022 a m√°s de 4% hacia finales de a√±o, velocidad m√°s r√°pida desde los a√±os 1980s bajo Paul Volcker. El Banco Central Europeo, Banco de Inglaterra y otros bancos centrales siguen decisiones de endurecimiento similares, marcando el fin definitivo de la era de dinero barato iniciada en 2008.‚Äã
GLTR experimenta choque de fuerzas contradictorias: riesgo geopol√≠tico extremo e inflaci√≥n acelerada favorecen oro como cobertura, pero tasas de inter√©s reales muy altas (superiores a 2% en t√©rminos reales hacia finales de 2022) encarecen dram√°ticamente su costo de oportunidad. El resultado es volatilidad extrema con GLTR oscilando entre $70‚Äì95, cerrando pr√°cticamente plano (~0% anual) sin direcci√≥n clara.
```{r Oro 2022}
# Oro 2022 (proxy: GLD)
gold_2022 <- getSymbols("GLD", src = "yahoo", auto.assign = FALSE,
                        from = "2022-01-01", to = "2022-12-31")
gold_2022_close <- Cl(gold_2022)

gold_2022_df <- data.frame(
  fecha  = index(gold_2022_close),
  precio = as.numeric(gold_2022_close)
)

g_oro_2022 <- ggplot(gold_2022_df, aes(x = fecha, y = precio)) +
  geom_line(color = "goldenrod", linewidth = 0.8) +
  labs(title = "Precio del oro en 2022 (proxy: GLD)",
       subtitle = "Volatilidad por guerra en Ucrania e incremento de tasas",
       x = "Fecha", y = "Precio de cierre (USD)") +
  theme_minimal()

g_oro_2022_int <- ggplotly(g_oro_2022)
g_oro_2022_int
```
La Figura 5 presenta la evoluci√≥n del precio del oro durante 2022 (proxy GLD), donde se observa un repunte brusco tras la invasi√≥n de Ucrania en febrero-marzo, alcanzando niveles cercanos a &#190 por acci√≥n de GLD (equivalente a ~&#1.950/oz de oro spot), seguido de una correcci√≥n sostenida a medida que se intensifica el ciclo de subidas de tasas durante el segundo semestre. Este patr√≥n respalda la idea de un a√±o dominado por fuerzas contrapuestas: el oro reacciona inicialmente como activo refugio ante el choque geopol√≠tico, pero pierde tracci√≥n cuando el endurecimiento monetario eleva de forma significativa las tasas reales, haciendo atractivos activos remunerados (bonos, dep√≥sitos) frente a oro que no genera rendimiento.

**Crisis bancaria regional y reactivaci√≥n de demanda refugio (marzo 2023)**
En marzo de 2023, la quiebra de Silicon Valley Bank (SVB) y otros bancos regionales (Signature Bank, First Republic) desencadena p√°nico bancario por riesgo de liquidez, no por insolvencia sist√©mica como en 2008. Los inversionistas reaccionan inmediatamente con demanda masiva por oro como refugio, que dispara por encima de 2.000 USD/oz en d√≠as. GLTR experimenta pico abrupto de 5‚Äì8%.‚Äã
Sin embargo, este es un evento t√°ctico, no estructural. Respuesta r√°pida de autoridades (garant√≠as de dep√≥sitos, l√≠neas de cr√©dito de emergencia) alivia tensiones y GLTR retrocede gradualmente, cerrando 2023 con rentabilidad ligeramente positiva de +2%. El patr√≥n es t√≠pico de shocks puntuales que generan picos temporales pero no tendencias sostenidas.

```{r 2023 vs 2024}
# Descargar datos para 2023 y 2024
GLTR_2023 <- getSymbols("GLTR", src = "yahoo", auto.assign = FALSE, from = "2023-01-01", to = "2023-12-31")
GLTR_2024 <- getSymbols("GLTR", src = "yahoo", auto.assign = FALSE, from = "2024-01-01", to = "2024-12-31")

# Preparar datos para 2023
datos_2023 <- data.frame(
  Fecha = index(GLTR_2023),
  Precio = as.numeric(Cl(GLTR_2023))
) %>%
  mutate(
    Dia = seq_along(Fecha),
    A√±o = "2023",
    Precio_Norm = Precio / first(Precio) * 100
  )

# Preparar datos para 2024
datos_2024 <- data.frame(
  Fecha = index(GLTR_2024),
  Precio = as.numeric(Cl(GLTR_2024))
) %>%
  mutate(
    Dia = seq_along(Fecha),
    A√±o = "2024",
    Precio_Norm = Precio / first(Precio) * 100
  )

# Combinar datos
datos_comparativos <- bind_rows(datos_2023, datos_2024)

# Crear gr√°fico comparativo interactivo
plot_ly(datos_comparativos, x = ~Dia) %>%
  # L√≠nea para 2023
  add_trace(data = subset(datos_comparativos, A√±o == "2023"),
            y = ~Precio_Norm,
            type = 'scatter',
            mode = 'lines',
            line = list(color = '#e0c3fc', width = 3),
            name = '2023',
            hoverinfo = 'text',
            text = ~paste('<b>2023 - D√≠a', Dia, '</b><br>',
                          'Fecha:', Fecha, '<br>',
                          'Precio: $', round(Precio, 2), '<br>',
                          'Normalizado:', round(Precio_Norm, 1))) %>%
  
  # L√≠nea para 2024
  add_trace(data = subset(datos_comparativos, A√±o == "2024"),
            y = ~Precio_Norm,
            type = 'scatter',
            mode = 'lines',
            line = list(color = '#957fef', width = 3),
            name = '2024',
            hoverinfo = 'text',
            text = ~paste('<b>2024 - D√≠a', Dia, '</b><br>',
                          'Fecha:', Fecha, '<br>',
                          'Precio: $', round(Precio, 2), '<br>',
                          'Normalizado:', round(Precio_Norm, 1))) %>%
  
  # L√≠nea de referencia en 100
  add_trace(x = c(0, max(datos_comparativos$Dia)),
            y = c(100, 100),
            type = 'scatter',
            mode = 'lines',
            line = list(color = 'gray', width = 1, dash = 'dash'),
            name = 'L√≠nea base (100)',
            showlegend = FALSE) %>%
  
  # Layout
  layout(
    title = list(
      text = '<b>Comparativo de Desempe√±o: ETF GLTR 2023 vs 2024</b>',
      font = list(size = 22, color = '#1E3A8A')
    ),
    xaxis = list(
      title = '<b>D√≠as de negociaci√≥n en el a√±o</b>',
      gridcolor = 'lightgray'
    ),
    yaxis = list(
      title = '<b>Precio Normalizado (Inicio = 100)</b>',
      gridcolor = 'lightgray'
    ),
    hovermode = 'x unified',
    plot_bgcolor = 'white',
    paper_bgcolor = '#F8F9FA',
    legend = list(
      orientation = 'h',
      x = 0.5,
      y = -0.15,
      xanchor = 'center'
    ),
    margin = list(t = 80, b = 100, l = 80, r = 40)
  )
```
La Figura 4 contrasta ambos per√≠odos: la crisis bancaria (febrero‚Äìmayo 2023) muestra trayectoria err√°tica con cambios frecuentes, mientras el rally 2024 (junio‚Äìoctubre) exhibe pendiente alcista pr√°cticamente lineal sin correcciones, evidenciando la diferencia entre evento t√°ctico y fundamentales s√≥lidos sostenidos

**Rally estructural y m√°ximos hist√≥ricos (2024‚Äì2025)**
A partir de enero de 2024, confluyen cuatro factores estructurales que generan rally robusto: la deuda p√∫blica en m√°ximos hist√≥ricos favorece oro como cobertura inflacionaria, los bancos centrales se√±alizan futuras reducciones de tasas reduciendo costo de oportunidad del oro, la guerra Ucrania y tensiones comerciales EE.UU.-China sustentan demanda de refugio, y las sanciones a Rusia presionan suministro de paladio.‚Äã
El resultado es una apreciaci√≥n pronunciada: GLTR sube de $100 a $140 en diez meses (ganancia de +40%), oro alcanza m√°ximos de 2.500+ USD/oz, y plata alcanza m√°ximos no vistos en d√©cada aproximadamente $30‚Äì32/oz. La aceleraci√≥n es concluyente en t√©rminos anuales: 2023 cierra plano con +2.1%, 2024 muestra rally de +21.2%, y 2025 hasta octubre registra +68.7%, confirmando intensificaci√≥n de factores fundamentales.

Figura 5. Desempe√±o comparativo por a√±o (2023‚Äì2025)
```{r Desempe√±o por a√±o}
# Descargar datos desde 2023
GLTR_all <- getSymbols("GLTR", src = "yahoo", auto.assign = FALSE, from = "2023-01-01")

# Funci√≥n para preparar datos por a√±o
preparar_datos_a√±o <- function(a√±o, datos) {
  # Filtrar por a√±o
  datos_a√±o <- datos[year(index(datos)) == a√±o]
  
  if (nrow(datos_a√±o) == 0) return(NULL)
  
  # Crear dataframe
  df <- data.frame(
    Fecha = index(datos_a√±o),
    Precio = as.numeric(Cl(datos_a√±o))
  )
  
  # Calcular d√≠a del a√±o y precio normalizado
  df <- df %>%
    mutate(
      Dia_del_a√±o = row_number(),
      A√±o = as.character(a√±o),
      Precio_Norm = Precio / first(Precio) * 100,
      Retorno = (Precio / first(Precio) - 1) * 100
    )
  
  return(df)
}

# Preparar datos para cada a√±o
datos_2023 <- preparar_datos_a√±o(2023, GLTR_all)
datos_2024 <- preparar_datos_a√±o(2024, GLTR_all)
datos_2025 <- preparar_datos_a√±o(2025, GLTR_all)

# Combinar todos los datos
datos_todos <- bind_rows(datos_2023, datos_2024, datos_2025)

# Crear gr√°fico interactivo
plot_ly(datos_todos, x = ~Dia_del_a√±o) %>%
  
  # A√±o 2023
  add_trace(data = subset(datos_todos, A√±o == "2023"),
            y = ~Precio_Norm,
            type = 'scatter',
            mode = 'lines+markers',
            line = list(color = '#b79ced', width = 2.5),
            marker = list(size = 6, color = '#dec0f1'),
            name = '2023',
            hoverinfo = 'text',
            text = ~paste('<b>2023 - D√≠a', Dia_del_a√±o, '</b><br>',
                          'Fecha:', format(Fecha, '%d/%m/%Y'), '<br>',
                          'Precio real: $', round(Precio, 2), '<br>',
                          'Normalizado:', round(Precio_Norm, 1), '<br>',
                          'Retorno:', round(Retorno, 1), '%')) %>%
  
  # A√±o 2024
  add_trace(data = subset(datos_todos, A√±o == "2024"),
            y = ~Precio_Norm,
            type = 'scatter',
            mode = 'lines+markers',
            line = list(color = '#8e94f2', width = 2.5),
            marker = list(size = 6, color = '#8e94f2'),
            name = '2024',
            hoverinfo = 'text',
            text = ~paste('<b>2024 - D√≠a', Dia_del_a√±o, '</b><br>',
                          'Fecha:', format(Fecha, '%d/%m/%Y'), '<br>',
                          'Precio real: $', round(Precio, 2), '<br>',
                          'Normalizado:', round(Precio_Norm, 1), '<br>',
                          'Retorno:', round(Retorno, 1), '%')) %>%
  
  # A√±o 2025 (hasta la fecha disponible)
  add_trace(data = subset(datos_todos, A√±o == "2025"),
            y = ~Precio_Norm,
            type = 'scatter',
            mode = 'lines+markers',
            line = list(color = '#1E3A8A', width = 2.5),
            marker = list(size = 6, color = '#1E3A8A'),
            name = '2025 (hasta fecha)',
            hoverinfo = 'text',
            text = ~paste('<b>2025 - D√≠a', Dia_del_a√±o, '</b><br>',
                          'Fecha:', format(Fecha, '%d/%m/%Y'), '<br>',
                          'Precio real: $', round(Precio, 2), '<br>',
                          'Normalizado:', round(Precio_Norm, 1), '<br>',
                          'Retorno:', round(Retorno, 1), '%')) %>%
  
  # L√≠nea de referencia en 100
  add_trace(x = c(0, max(datos_todos$Dia_del_a√±o, na.rm = TRUE)),
            y = c(100, 100),
            type = 'scatter',
            mode = 'lines',
            line = list(color = 'gray', width = 1, dash = 'dash'),
            name = 'L√≠nea base (100)',
            showlegend = FALSE,
            hoverinfo = 'skip') %>%
  
  # Layout
  layout(
    title = list(
      text = '<b>Comparativo de Desempe√±o Anual - ETF GLTR</b><br><span style="font-size:14px">Cada a√±o normalizado a 100 en su primer d√≠a de negociaci√≥n</span>',
      font = list(size = 22, color = '#1E3A8A')
    ),
    xaxis = list(
      title = '<b>D√≠a del a√±o de negociaci√≥n</b>',
      gridcolor = 'lightgray'
    ),
    yaxis = list(
      title = '<b>√çndice Normalizado (Inicio = 100)</b>',
      gridcolor = 'lightgray'
    ),
    hovermode = 'x unified',
    plot_bgcolor = 'white',
    paper_bgcolor = '#F8F9FA',
    legend = list(
      orientation = 'h',
      x = 0.5,
      y = -0.15,
      xanchor = 'center',
      bgcolor = 'rgba(255,255,255,0.8)'
    ),
    margin = list(t = 100, b = 100, l = 80, r = 40),
    
    # Anotaciones con rendimiento final de cada a√±o
    annotations = list(
      list(
        x = max(datos_2023$Dia_del_a√±o, na.rm = TRUE),
        y = tail(datos_2023$Precio_Norm, 1),
        text = paste('2023:', round(tail(datos_2023$Retorno, 1), 1), '%'),
        showarrow = FALSE,
        font = list(size = 12, color = '#b7bced'),
        xanchor = 'left',
        xshift = 10
      ),
      list(
        x = max(datos_2024$Dia_del_a√±o, na.rm = TRUE),
        y = tail(datos_2024$Precio_Norm, 1),
        text = paste('2024:', round(tail(datos_2024$Retorno, 1), 1), '%'),
        showarrow = FALSE,
        font = list(size = 12, color = '#8e94f2'),
        xanchor = 'left',
        xshift = 10
      ),
      list(
        x = max(datos_2025$Dia_del_a√±o, na.rm = TRUE),
        y = tail(datos_2025$Precio_Norm, 1),
        text = paste('2025:', round(tail(datos_2025$Retorno, 1), 1), '%'),
        showarrow = FALSE,
        font = list(size = 12, color = '#1E3A8A'),
        xanchor = 'left',
        xshift = 10
      )
    )
  )
```
La serie captura transici√≥n cr√≠tica desde crisis t√°ctica en 2023 hasta rally estructural en 2024‚Äì2025, evidenciando no estacionariedad que justifica ARIMA para capturar cambios de r√©gimen y realizar pron√≥sticos condicionales al entorno macroecon√≥mico actual.

**S√≠ntesis: Estructura de la serie y factores determinantes.**

La trayectoria de 15 a√±os (2010‚Äì2025) se sintetiza de la siguiente manera: 

```{r T de sintesis hist√≥rica}

# Crear tabla de s√≠ntesis hist√≥rica
sintesis_historica <- data.frame(
  Per√≠odo = c(
    "2010‚Äì2012",
    "2013‚Äì2015", 
    "2016‚Äì2019",
    "2020",
    "2021",
    "2022",
    "2023",
    "2024‚Äì2025"
  ),
  Comportamiento = c(
    "Rally alcista",
    "Correcci√≥n",
    "Laterizaci√≥n vol√°til",
    "Rally extremo",
    "Correcci√≥n",
    "Volatilidad extrema",
    "Recuperaci√≥n t√°ctica",
    "Rally estructural"
  ),
  Factores_clave = c(
    "Est√≠mulos post-2008, temor inflaci√≥n, b√∫squeda refugio",
    "Tapering Fed, fortaleza d√≥lar, normalizaci√≥n monetaria",
    "Incertidumbre pol√≠tica (Brexit, Trump, guerra comercial), tasas moderadas",
    "Pandemia COVID, p√°nico financiero, QE infinito, m√°ximos oro",
    "Recuperaci√≥n econ√≥mica, rotaci√≥n a c√≠clicos, normalizaci√≥n de tasas",
    "Invasi√≥n Ucrania (alcista) vs. endurecimiento Fed (bajista) ‚Üí plano",
    "Crisis bancaria puntual, demanda refugio moment√°nea, luego normalizaci√≥n",
    "Deuda p√∫blica ‚Üë, tasas reales esperadas ‚Üì, incertidumbre geopol√≠tica, m√°ximos hist√≥ricos"
  )
)

# Crear tabla profesional
sintesis_historica %>%
  kable(
    align = "lll",
    col.names = c("PER√çODO", "COMPORTAMIENTO", "FACTORES CLAVE"),
    caption = "<center><h3 style='color: #1E3A8A;'>Tabla 2. S√çNTESIS HIST√ìRICA - TRAYECTORIA DEL ETF GLTR (2010-2025)</h3></center>",
    escape = FALSE
  ) %>%
  kable_styling(
    bootstrap_options = c("striped", "hover", "condensed"),
    full_width = FALSE,
    position = "center",
    font_size = 13,
    fixed_thead = TRUE
  ) %>%
  row_spec(
    0,
    background = "#957fef",
    color = "white",
    bold = TRUE,
    align = "center",
    extra_css = "border-bottom: 2px solid #FFFFFF;"
  ) %>%
  column_spec(
    1,
    bold = TRUE,
    width = "15%",
    background = "#F8FAFC",
    extra_css = "border-right: 1px solid #E5E7EB;"
  ) %>%
  column_spec(
    2,
    width = "20%",
    background = "#FFFFFF",
    extra_css = "border-right: 1px solid #E5E7EB;"
  ) %>%
  column_spec(
    3,
    width = "65%",
    background = "#FFFFFF"
  ) %>%
  # A√±adir notas al pie
  footnote(
    general = "Fuente: An√°lisis hist√≥rico basado en datos de Yahoo Finance, Bloomberg y Aberdeen Standard Investments",
    general_title = "Nota:",
    footnote_as_chunk = TRUE,
    title_format = c("italic", "bold")
  )
```
GLTR no es estacionaria porque est√° impulsada por ciclos macroecon√≥micos, decisiones de bancos centrales y cambios en percepci√≥n de riesgo global‚Äîtodos no estacionarios. La ventana 2022‚Äì2025 captura transici√≥n clara desde volatilidad extrema (2022) a rally s√≥lido (2024‚Äì2025), validando aplicabilidad de ARIMA para capturar cambios de r√©gimen y realizar pron√≥sticos condicionales.‚Äã



## Estadisticas descriptivas

**Tabla indicadores estadisticos**

La Tabla 2 presenta un resumen num√©rico de los estad√≠sticos descriptivos fundamentales del ETF GLTR durante el per√≠odo de an√°lisis comprendido entre octubre de 2022 y octubre de 2025.
```{T de estadisticas descriptivas}
# Calcular estad√≠sticas b√°sicas
estadisticas_basicas <- GLTR_df %>%
  filter(Fecha >= "2022-10-31" & Fecha <= "2025-10-31") %>%
  summarise(
    Media = mean(Precio),
    Mediana = median(Precio),
    Desviacion = sd(Precio),
    Minimo = min(Precio),
    Maximo = max(Precio),
    Q1 = quantile(Precio, 0.25),
    Q3 = quantile(Precio, 0.75)
  ) %>%
  mutate(across(where(is.numeric), ~round(., 2)))

# Crear el data frame directamente
estadisticas_df <- data.frame(
  Estadistica = c("Media", "Mediana", "Desviaci√≥n Est√°ndar", 
                  "M√≠nimo", "M√°ximo", "Primer Cuartil (Q1)", 
                  "Tercer Cuartil (Q3)"),
  Valor = c(
    estadisticas_basicas$Media,
    estadisticas_basicas$Mediana,
    estadisticas_basicas$Desviacion,
    estadisticas_basicas$Minimo,
    estadisticas_basicas$Maximo,
    estadisticas_basicas$Q1,
    estadisticas_basicas$Q3
  )
)

# Crear tabla con GT - versi√≥n simplificada
tabla_estadisticas <- estadisticas_df %>%
  gt() %>%
  tab_header(
    title = "Tabla 1. Estad√≠sticas Descriptivas del ETF GLTR",
    subtitle = "Per√≠odo: Octubre 2022 - Octubre 2025"
  ) %>%
  fmt_currency(
    columns = Valor,
    currency = "USD",
    decimals = 2
  ) %>%
  cols_label(
    Estadistica = "Estad√≠stica",
    Valor = "Valor (USD)"
  ) %>%
  # Estilo para encabezado de columnas
  tab_style(
    style = list(
      cell_fill(color = "#957fef"),
      cell_text(color = "white", weight = "bold")
    ),
    locations = cells_column_labels()
  ) %>%
  # Estilo para filas alternas
  tab_style(
    style = cell_fill(color = "#f8f9fa"),
    locations = cells_body(rows = seq(1, nrow(estadisticas_df), 2))
  ) %>%
  # Bordes
  tab_style(
    style = cell_borders(
      sides = c("top", "bottom"),
      color = "#dee2e6",
      weight = px(1)
    ),
    locations = cells_body()
  ) %>%
  # Fuente de nota
  tab_source_note(
    source_note = "Fuente: Datos hist√≥ricos del ETF GLTR"
  ) %>%
  # Opciones b√°sicas de tabla
  tab_options(
    table.font.names = "Arial",
    heading.title.font.size = px(16),
    heading.subtitle.font.size = px(14),
    table_body.hlines.color = "transparent",
    source_notes.font.size = px(12)
  )

# Mostrar la tabla
tabla_estadisticas

```

El precio promedio fue de &#107.28 USD con una mediana de &#101.79 USD. La diferencia de &#5.49 entre ambas medidas sugiere una distribuci√≥n ligeramente asim√©trica hacia valores superiores, caracter√≠stica t√≠pica de series financieras donde eventos de apreciaci√≥n significativa generan colas derechas prolongadas. La desviaci√≥n est√°ndar de &#22.90 USD (21.3% de la media) evidencia una variabilidad considerable, t√≠pica en mercados de metales preciosos sujetos a ciclos econ√≥micos y expectativas inflacionarias.
El an√°lisis de cuartiles revela una perspectiva m√°s matizada: con Q1 en &#88.58 USD y Q3 en &#119.92 USD, el rango intercuart√≠lico de &#31.34 USD indica que el 50% central de las observaciones fue relativamente estrecho comparado con la amplitud total de &#109.79 USD. Los valores extremos fueron ocasionales, no representativos del comportamiento t√≠pico de la serie.

**Distribuci√≥n de Precios por A√±o: An√°lisis del Boxplot Interactivo**

La visualizaci√≥n mediante boxplots interactivos muestra el comportamiento de la serie temporal por a√±o calendario, exponiendo la evoluci√≥n de la tendencia central, dispersi√≥n y valores extremos a lo largo del per√≠odo de entrenamiento. Este an√°lisis comparativo revela heterogeneidades temporales en la variabilidad de precios, distinguiendo a√±os de estabilidad relativa frente a per√≠odos de volatilidad extrema‚Äîinformaci√≥n esencial para comprender los cambios estructurales de la serie y anticipar la especificaci√≥n del modelo de pron√≥stico.
```{r boxplot por a√±os}

# Asegurarnos de que la columna Fecha es de tipo Date
GLTR_df <- GLTR_df %>%
  mutate(Fecha = as.Date(Fecha))

# Extraer el a√±o para el an√°lisis
GLTR_df <- GLTR_df %>%
  mutate(A√±o = as.factor(format(Fecha, "%Y"))) %>%
  filter(A√±o %in% c("2022", "2023", "2024", "2025"))

# Crear dataframes separados para cada a√±o
df_2022 <- GLTR_df %>% filter(A√±o == "2022")
df_2023 <- GLTR_df %>% filter(A√±o == "2023")
df_2024 <- GLTR_df %>% filter(A√±o == "2024")
df_2025 <- GLTR_df %>% filter(A√±o == "2025")

# Definir colores elegantes para cada a√±o
colors <- c(
  "2022" = "#efd9ce",   
  "2023" = "#dec0f1",    
  "2024" = "#b79ced",    
  "2025" = "#957fef",    
  "Todos" = "#6C757D"    # Gris para "Todos"
)

# Crear el gr√°fico base con todos los a√±os
fig <- plot_ly() %>%
  # Trazo para 2022
  add_boxplot(
    data = df_2022,
    y = ~Precio,
    name = "2022",
    marker = list(
      color = colors["2022"],
      size = 5,
      line = list(color = 'white', width = 1)
    ),
    line = list(color = colors["2022"], width = 2),
    fillcolor = 'rgba(46, 134, 171, 0.5)',
    boxmean = TRUE,
    visible = TRUE
  ) %>%
  # Trazo para 2023
  add_boxplot(
    data = df_2023,
    y = ~Precio,
    name = "2023",
    marker = list(
      color = colors["2023"],
      size = 5,
      line = list(color = 'white', width = 1)
    ),
    line = list(color = colors["2023"], width = 2),
    fillcolor = 'rgba(162, 59, 114, 0.5)',
    boxmean = TRUE,
    visible = TRUE
  ) %>%
  # Trazo para 2024
  add_boxplot(
    data = df_2024,
    y = ~Precio,
    name = "2024",
    marker = list(
      color = colors["2024"],
      size = 5,
      line = list(color = 'white', width = 1)
    ),
    line = list(color = colors["2024"], width = 2),
    fillcolor = 'rgba(241, 143, 1, 0.5)',
    boxmean = TRUE,
    visible = TRUE
  ) %>%
  # Trazo para 2025
  add_boxplot(
    data = df_2025,
    y = ~Precio,
    name = "2025",
    marker = list(
      color = colors["2025"],
      size = 5,
      line = list(color = 'white', width = 1)
    ),
    line = list(color = colors["2025"], width = 2),
    fillcolor = 'rgba(115, 171, 132, 0.5)',
    boxmean = TRUE,
    visible = TRUE
  ) %>%
  # Dise√±o del gr√°fico
  layout(
    title = list(
      text = "<b>Boxplot Interactivo: Distribuci√≥n de Precios del ETF GLTR</b>",
      font = list(
        family = "Arial, sans-serif",
        size = 22,
        color = "#2c3e50"
      ),
      x = 0.5,
      xanchor = "center",
      y = 0.95
    ),
    xaxis = list(
      title = "<b>A√±o</b>",
      titlefont = list(
        family = "Arial, sans-serif",
        size = 16,
        color = "#2c3e50"
      ),
      tickfont = list(
        family = "Arial, sans-serif",
        size = 14,
        color = "#2c3e50"
      ),
      showgrid = TRUE,
      gridcolor = "rgba(200, 200, 200, 0.2)",
      gridwidth = 0.5,
      showline = TRUE,
      linecolor = "#bdc3c7",
      linewidth = 1.5
    ),
    yaxis = list(
      title = "<b>Precio (USD)</b>",
      titlefont = list(
        family = "Arial, sans-serif",
        size = 16,
        color = "#2c3e50"
      ),
      tickfont = list(
        family = "Arial, sans-serif",
        size = 13,
        color = "#2c3e50"
      ),
      tickformat = "$.2f",
      showgrid = TRUE,
      gridcolor = "rgba(200, 200, 200, 0.2)",
      gridwidth = 0.5,
      zeroline = TRUE,
      zerolinecolor = "#bdc3c7",
      zerolinewidth = 1
    ),
    plot_bgcolor = "rgba(255, 255, 255, 0.95)",
    paper_bgcolor = "rgba(248, 249, 250, 1)",
    margin = list(l = 80, r = 40, t = 100, b = 80),
    showlegend = TRUE,
    legend = list(
      orientation = "h",
      x = 0.5,
      xanchor = "center",
      y = -0.15,
      font = list(
        family = "Arial, sans-serif",
        size = 13
      )
    ),
    hovermode = "x unified",
    # Definir los botones de actualizaci√≥n
    updatemenus = list(
      list(
        type = "buttons",
        direction = "right",
        x = 0.5,
        xanchor = "center",
        y = 1.15,
        yanchor = "top",
        showactive = TRUE,
        bgcolor = "rgba(255, 255, 255, 0.8)",
        bordercolor = "#dee2e6",
        borderwidth = 1,
        buttons = list(
          # Bot√≥n para mostrar TODOS los a√±os
          list(
            method = "update",
            args = list(
              list(visible = c(TRUE, TRUE, TRUE, TRUE)),
              list(title = "<b>Boxplot Interactivo: Distribuci√≥n de Precios del ETF GLTR (Todos los A√±os)</b>",
                   xaxis = list(title = "<b>A√±o</b>"))
            ),
            label = "Todos los A√±os"
          ),
          # Bot√≥n para mostrar solo 2022
          list(
            method = "update",
            args = list(
              list(visible = c(TRUE, FALSE, FALSE, FALSE)),
              list(title = "<b>Boxplot Interactivo: Distribuci√≥n de Precios del ETF GLTR (2022)</b>",
                   xaxis = list(title = "<b>2022</b>"))
            ),
            label = "2022"
          ),
          # Bot√≥n para mostrar solo 2023
          list(
            method = "update",
            args = list(
              list(visible = c(FALSE, TRUE, FALSE, FALSE)),
              list(title = "<b>Boxplot Interactivo: Distribuci√≥n de Precios del ETF GLTR (2023)</b>",
                   xaxis = list(title = "<b>2023</b>"))
            ),
            label = "2023"
          ),
          # Bot√≥n para mostrar solo 2024
          list(
            method = "update",
            args = list(
              list(visible = c(FALSE, FALSE, TRUE, FALSE)),
              list(title = "<b>Boxplot Interactivo: Distribuci√≥n de Precios del ETF GLTR (2024)</b>",
                   xaxis = list(title = "<b>2024</b>"))
            ),
            label = "2024"
          ),
          # Bot√≥n para mostrar solo 2025
          list(
            method = "update",
            args = list(
              list(visible = c(FALSE, FALSE, FALSE, TRUE)),
              list(title = "<b>Boxplot Interactivo: Distribuci√≥n de Precios del ETF GLTR (2025)</b>",
                   xaxis = list(title = "<b>2025</b>"))
            ),
            label = "2025"
          )
        )
      )
    )
  ) %>%
  # A√±adir informaci√≥n de hover personalizada
  layout(
    hoverlabel = list(
      bgcolor = "white",
      bordercolor = "#dee2e6",
      font = list(
        family = "Arial, sans-serif",
        size = 13,
        color = "#2c3e50"
      )
    )
  ) %>%
  # A√±adir anotaci√≥n explicativa
  add_annotations(
    text = "<i>Haz clic en los botones para ver la distribuci√≥n de precios por a√±o</i>",
    x = 0.5,
    y = -0.2,
    xref = "paper",
    yref = "paper",
    xanchor = "center",
    showarrow = FALSE,
    font = list(
      family = "Arial, sans-serif",
      size = 12,
      color = "#6c757d"
    )
  )

# Mostrar el gr√°fico interactivo
fig
```
 El a√±o 2022 se caracteriza por una distribuci√≥n estrecha y homog√©nea, con una mediana de &#86.62 USD y un rango intercuart√≠lico de apenas &#1.73 USD. La caja del boxplot es pr√°cticamente invisible, indicando que el 50% central de las observaciones estuvo concentrado en un intervalo min√∫sculo. El rango total fue de &#10.59 USD, representando una variabilidad relativa del 13.4% respecto a la mediana. La media (&#85.88) y la mediana (&#86.62) est√°n pr√°cticamente alineadas, sugiriendo una distribuci√≥n sim√©trica con ausencia de picos significativos. 

Durante 2023 se observa un incremento moderado pero notable en los niveles de precio, con una mediana de &#88.86 USD, representando un aumento del 2.6% respecto a 2022. El rango intercuart√≠lico aument√≥ a &#4.10 USD, triplic√°ndose respecto al a√±o anterior, lo que indica una expansi√≥n de la variabilidad dentro del rango central. El rango total se ampli√≥ a &#14.09 USD, con m√°ximos alcanzando &#95.57. La media (&#88.85) nuevamente coincide pr√°cticamente con la mediana ($88.86), manteniendo la simetr√≠a distribucional. Este a√±o marca una transici√≥n: los precios comenzaron a recuperarse gradualmente de los m√≠nimos de 2022, pero la volatilidad a√∫n se mantuvo contenida.

El a√±o 2024 presenta un salto significativo en los niveles de precio, con una mediana de &#104.56 USD, equivalente a un incremento del 17.7% respecto a 2023. El rango intercuart√≠lico creci√≥ sustancialmente a &#12.78 USD, representando casi el triple del observado en 2023. La caja del boxplot se expande visiblemente, reflejando una mayor dispersi√≥n en las observaciones centrales. El rango total fue de &#36.22 USD, con una variabilidad relativa del 34.7% respecto a la mediana. La media (&#103.62) nuevamente se alinea con la mediana (&#104.56), manteniendo simetr√≠a.
El a√±o 2025 (per√≠odo parcial de enero a octubre) muestra la mayor apreciaci√≥n y volatilidad de todo el per√≠odo, con una mediana de &#138.65 USD, generando un aumento del 32.6% respecto a 2024. El rango intercuart√≠lico alcanz√≥ &#27.41 USD, la mayor dispersi√≥n registrada en los cuatro a√±os y aproximadamente 6.7 veces mayor que la de 2022. La caja es considerablemente m√°s amplia, reflejando una heterogeneidad considerable en la distribuci√≥n central. El rango total fue de &#77.48 USD, con una variabilidad relativa del 55.9% respecto a la mediana, la m√°s elevada del per√≠odo. La media (&#141.72) se mantiene ligeramente superior a la mediana ($138.65), sugiriendo eventos de precios particularmente elevados que mueven el promedio.
La progresi√≥n del 2022 al 2025 revela un patr√≥n de volatilidad creciente acompa√±ado de apreciaci√≥n sistem√°tica. Mientras que en 2022 la distribuci√≥n fue cristalina y homog√©nea (IQR = &#1.73), en 2025 la dispersi√≥n se multiplic√≥ por m√°s de 15 veces (IQR = &#27.41). 

**Gr√°fico de tendencias**

La visualizaci√≥n de la serie temporal superpuesta con su componente de tendencia separa el comportamiento del precio en dos dimensiones: los precios diarios y la direcci√≥n subyacente de largo plazo.
```{r Tendencia}
# Convertir a serie temporal para descomposici√≥n
serie_ts <- ts(GLTR_df$Precio, 
               start = c(2022, 10), 
               frequency = 365)

# Descomposici√≥n STL (Seasonal and Trend decomposition using Loess)
descomposicion <- stl(serie_ts, s.window = "periodic")

# Crear dataframe para plotly
descomp_df <- data.frame(
  Fecha = GLTR_df$Fecha,
  Original = GLTR_df$Precio,
  Tendencia = as.numeric(descomposicion$time.series[, "trend"])
)

# Gr√°fico interactivo de solo Original + Tendencia
fig_original_tendencia <- plot_ly(descomp_df) %>%
  # Serie original
  add_trace(x = ~Fecha, y = ~Original, type = 'scatter', mode = 'lines',
            name = 'Serie Original', 
            line = list(color = 'rgba(46, 134, 171, 0.4)', width = 1),
            hovertemplate = '<b>Original</b>: $%{y:.2f}<br>%{x|%d-%b-%Y}<extra></extra>') %>%
  # Tendencia
  add_trace(x = ~Fecha, y = ~Tendencia, type = 'scatter', mode = 'lines',
            name = 'Tendencia', 
            line = list(color = '#7161ef', width = 3),
            hovertemplate = '<b>Tendencia</b>: $%{y:.2f}<br>%{x|%d-%b-%Y}<extra></extra>') %>%
  # Dise√±o del gr√°fico
  layout(
    title = list(
      text = "<b>Serie Temporal Original y Tendencia del ETF GLTR</b>",
      font = list(
        family = "Arial, sans-serif",
        size = 22,
        color = "#2c3e50"
      ),
      x = 0.5,
      xanchor = "center",
      y = 0.95
    ),
    xaxis = list(
      title = "<b>Fecha</b>",
      titlefont = list(
        family = "Arial, sans-serif",
        size = 16,
        color = "#2c3e50"
      ),
      tickfont = list(
        family = "Arial, sans-serif",
        size = 12,
        color = "#2c3e50"
      ),
      showgrid = TRUE,
      gridcolor = "rgba(200, 200, 200, 0.2)",
      gridwidth = 0.5,
      showline = TRUE,
      linecolor = "#bdc3c7",
      linewidth = 1.5,
      rangeslider = list(visible = FALSE)  # Range slider desactivado
    ),
    yaxis = list(
      title = "<b>Precio (USD)</b>",
      titlefont = list(
        family = "Arial, sans-serif",
        size = 16,
        color = "#2c3e50"
      ),
      tickfont = list(
        family = "Arial, sans-serif",
        size = 13,
        color = "#2c3e50"
      ),
      tickformat = "$.2f",
      showgrid = TRUE,
      gridcolor = "rgba(200, 200, 200, 0.2)",
      gridwidth = 0.5,
      zeroline = TRUE,
      zerolinecolor = "#bdc3c7",
      zerolinewidth = 1
    ),
    plot_bgcolor = "rgba(255, 255, 255, 0.95)",
    paper_bgcolor = "rgba(248, 249, 250, 1)",
    margin = list(l = 80, r = 40, t = 100, b = 80),
    hovermode = "x unified",
    # Botones de actualizaci√≥n
    updatemenus = list(
      list(
        type = "buttons",
        direction = "right",
        x = 0.5,
        xanchor = "center",
        y = 1.15,
        yanchor = "top",
        showactive = TRUE,
        bgcolor = "rgba(255, 255, 255, 0.9)",
        bordercolor = "#dee2e6",
        borderwidth = 1,
        buttons = list(
          # Bot√≥n para mostrar AMBAS series
          list(
            method = "update",
            args = list(
              list(visible = c(TRUE, TRUE)),
              list(title = "<b>Serie Temporal Original y Tendencia del ETF GLTR</b>")
            ),
            label = "Mostrar Ambas"
          ),
          # Bot√≥n para mostrar solo la SERIE ORIGINAL
          list(
            method = "update",
            args = list(
              list(visible = c(TRUE, FALSE)),
              list(title = "<b>Serie Temporal Original del ETF GLTR</b>")
            ),
            label = "Solo Original"
          ),
          # Bot√≥n para mostrar solo la TENDENCIA
          list(
            method = "update",
            args = list(
              list(visible = c(FALSE, TRUE)),
              list(title = "<b>Tendencia de la Serie Temporal del ETF GLTR</b>")
            ),
            label = "Solo Tendencia"
          )
        )
      )
    ),
    # Leyenda
    legend = list(
      orientation = "h",
      x = 0.5,
      xanchor = "center",
      y = -0.15,
      font = list(
        family = "Arial, sans-serif",
        size = 13
      ),
      bgcolor = "rgba(255, 255, 255, 0.8)",
      bordercolor = "#dee2e6",
      borderwidth = 1
    )
  ) %>%
  # Informaci√≥n de hover personalizada
  layout(
    hoverlabel = list(
      bgcolor = "white",
      bordercolor = "#dee2e6",
      font = list(
        family = "Arial, sans-serif",
        size = 13,
        color = "#2c3e50"
      )
    )
  ) %>%
  # A√±adir anotaci√≥n explicativa
  add_annotations(
    text = "<i>La l√≠nea azul clara muestra los precios originales diarios. La l√≠nea roja muestra la tendencia suavizada extra√≠da de la serie.</i>",
    x = 0.5,
    y = -0.25,
    xref = "paper",
    yref = "paper",
    xanchor = "center",
    showarrow = FALSE,
    font = list(
      family = "Arial, sans-serif",
      size = 12,
      color = "#6c757d"
    )
  )

# Mostrar el gr√°fico interactivo
fig_original_tendencia

```
La gr√°fica revela una tendencia claramente positiva y persistente a lo largo del per√≠odo (enero 2023 - octubre 2025). La l√≠nea de tendencia suavizada muestra una trayectoria ascendente consistente, partiendo de aproximadamente &#88 USD y alcanzando alrededor de &#160 USD. La serie original oscila continuamente alrededor de la tendencia, con fluctuaciones de corto plazo que aumentan progresivamente en magnitud conforme avanza el per√≠odo.

**Heatmap de estacionalidad y rendimiento**
El heat map visualiza los rendimientos porcentuales mensuales del ETF GLTR, permitiendo identificar patrones recurrentes estacionales.
```{r Heatmap de estacionalidad y rendimiento}
# Asegurarse de que la columna Fecha es de tipo Date
GLTR_df <- GLTR_df %>%
  mutate(Fecha = as.Date(Fecha))

# Preparar datos para heatmap mensual
heatmap_df <- GLTR_df %>%
  filter(Fecha >= "2022-10-31" & Fecha <= "2025-10-31") %>%
  mutate(
    A√±o = format(Fecha, "%Y"),
    Mes_num = as.numeric(format(Fecha, "%m")),
    Mes = factor(
      Mes_num,
      levels = 1:12,
      labels = c("Ene", "Feb", "Mar", "Abr", "May", "Jun",
                 "Jul", "Ago", "Sep", "Oct", "Nov", "Dic")
    )
  ) %>%
  group_by(A√±o, Mes, Mes_num) %>%
  summarise(
    Precio_Inicial = first(Precio, order_by = Fecha),
    Precio_Final = last(Precio, order_by = Fecha),
    Precio_Promedio = mean(Precio, na.rm = TRUE),
    .groups = 'drop'
  ) %>%
  mutate(
    Rendimiento = ifelse(Precio_Inicial > 0, 
                         (Precio_Final - Precio_Inicial) / Precio_Inicial * 100,
                         0)
  ) %>%
  arrange(A√±o, Mes_num)

# Gr√°fico de heatmap con escala ajustada a -15% a 15%
fig_estacionalidad_heatmap <- plot_ly(
  data = heatmap_df,
  x = ~Mes,
  y = ~A√±o,
  z = ~Rendimiento,
  type = 'heatmap',
  colorscale = list(
    c(0, 'rgb(229, 57, 53)'),      
    c(0.5, 'rgb(244, 244, 244)'),  
    c(1, 'rgb(46, 134, 171)')      
  ),
  zmin = -15,  
  zmax = 15,   
  colorbar = list(
    title = "Rendimiento (%)",
    titleside = "right",
    tickformat = ".1f",
    len = 0.8,
    tickvals = seq(-15, 15, by = 5)  # Marcas cada 5%
  ),
  hovertemplate = paste(
    '<b>A√±o</b>: %{y}<br>',
    '<b>Mes</b>: %{x}<br>',
    '<b>Rendimiento</b>: %{z:.2f}%<br>',
    '<b>Precio inicial</b>: $%{text:.2f}<br>',
    '<extra></extra>'
  ),
  text = ~Precio_Inicial
) %>%
  layout(
    title = list(
      text = "<b>Heatmap de Estacionalidad Mensual - Rendimientos por Mes</b>",
      font = list(
        family = "Arial, sans-serif",
        size = 22,
        color = "#2c3e50"
      ),
      x = 0.5,
      xanchor = "center",
      y = 0.95
    ),
    xaxis = list(
      title = "<b>Mes</b>",
      titlefont = list(
        family = "Arial, sans-serif",
        size = 16,
        color = "#2c3e50"
      ),
      tickfont = list(
        family = "Arial, sans-serif",
        size = 13,
        color = "#2c3e50"
      ),
      tickangle = 0,
      showgrid = FALSE
    ),
    yaxis = list(
      title = "<b>A√±o</b>",
      titlefont = list(
        family = "Arial, sans-serif",
        size = 16,
        color = "#2c3e50"
      ),
      tickfont = list(
        family = "Arial, sans-serif",
        size = 13,
        color = "#2c3e50"
      ),
      autorange = "reversed",
      showgrid = FALSE,
      type = "category"
    ),
    plot_bgcolor = "rgba(255, 255, 255, 0.95)",
    paper_bgcolor = "rgba(248, 249, 250, 1)",
    margin = list(l = 80, r = 40, t = 100, b = 80),
    annotations = list(
      list(
        x = 0.5,
        y = -0.15,
        text = "<i>Cada celda muestra el rendimiento porcentual mensual. Escala: -15% a +15%. Rojo = rendimiento negativo, Azul = rendimiento positivo.</i>",
        showarrow = FALSE,
        xref = "paper",
        yref = "paper",
        xanchor = "center",
        font = list(
          family = "Arial, sans-serif",
          size = 12,
          color = "#6c757d"
        )
      )
    )
  )

# Mostrar el heatmap
fig_estacionalidad_heatmap

```
El heat map revela una ausencia de patrones estacionales consistentes y pronunciados en los rendimientos mensuales del ETF GLTR. A diferencia de muchos activos financieros que exhiben "efectos enero" o depresiones estacionales definidas, los rendimientos mensuales de este ETF no muestran una estructura claramente repetible a√±o tras a√±o. 
En 2022, se observa una ligera preponderancia de rendimientos negativos (tonos rosados) en febrero-marzo y mayo-junio, mientras que octubre destaca como mes de rendimiento positivo robusto. 
En 2023, los rendimientos mensuales son mayormente d√©biles o negativos (predominio de tonos p√°lidos y rosados), con excepci√≥n de marzo y julio que muestran un leve matiz azul.
En 2024 y 2025, los patrones son a√∫n m√°s irregulares, con meses espec√≠ficos como octubre de 2022 y octubre de 2024 mostrando rendimientos excepcionales (azul intenso), pero sin que octubre se consolide como mes sistem√°ticamente favorable en todos los a√±os.
El an√°lisis identifica al mes de febrero de 2023 como el peor rendimiento hist√≥rico del ETF durante el per√≠odo de entrenamiento, con una depreciaci√≥n de -9.96% partiendo de un precio inicial de &#91.92 USD. En contraste, septiembre de 2025 emerge como el mejor mes, exhibiendo una apreciaci√≥n robusta de +10.75% desde un precio inicial de &#149.39 USD. Esta dicotom√≠a extrema (amplitud de 20.71 puntos porcentuales entre el peor y mejor mes) evidencia la volatilidad considerable en rendimientos mensuales, pero el hecho de que estos extremos ocurren en meses diferentes (febrero y septiembre) y en a√±os distantes refuerza la conclusi√≥n de que no existe un efecto estacional genuino y replicable que privilegie o penalice sistem√°ticamente meses espec√≠ficos.

**Bandas de volatilidad**

Las bandas visualizan la evoluci√≥n din√°mica de la volatilidad, superponiendo el precio de cierre diario, la media  y las bandas que se expanden o contraen seg√∫n la desviaci√≥n est√°ndar.
```{r Bandas de volatilidad}

# Calcular medias m√≥viles y bandas de volatilidad
volatilidad_df <- GLTR_df %>%
  arrange(Fecha) %>%
  mutate(
    Media_Movil_20 = SMA(Precio, n = 20),
    Desviacion_20 = runSD(Precio, n = 20),
    Banda_Superior = Media_Movil_20 + (2 * Desviacion_20),
    Banda_Inferior = Media_Movil_20 - (2 * Desviacion_20),
    Ancho_Banda = Banda_Superior - Banda_Inferior
  )

# Gr√°fico elegante de bandas de volatilidad
fig_bandas <- plot_ly(volatilidad_df, x = ~Fecha) %>%
  # √Årea entre bandas (volatilidad) - SOLO MUESTRA ANCHO
  add_ribbons(
    ymin = ~Banda_Inferior,
    ymax = ~Banda_Superior,
    name = 'Banda de Volatilidad',
    fillcolor = 'rgba(46, 134, 171, 0.15)',
    line = list(color = 'transparent'),
    hovertemplate = 'Ancho: $%{customdata:.2f}<extra></extra>',
    customdata = ~Ancho_Banda  # Solo muestra el ancho de banda
  ) %>%
  # L√≠nea de precio
  add_trace(
    y = ~Precio, 
    type = 'scatter', 
    mode = 'lines',
    name = 'Precio GLTR',
    line = list(color = '#2c3e50', width = 1.5),
    hovertemplate = 'Precio: $%{y:.2f}<extra></extra>'
  ) %>%
  # Media m√≥vil
  add_trace(
    y = ~Media_Movil_20, 
    type = 'scatter', 
    mode = 'lines',
    name = 'Media M√≥vil 20 d√≠as',
    line = list(color = '#FF6F61', width = 2, dash = 'dash'),
    hovertemplate = 'Media 20d: $%{y:.2f}<extra></extra>'
  ) %>%
  layout(
    title = list(
      text = "<b>Bandas de Volatilidad del ETF GLTR</b><br><sub>Las bandas se expanden en periodos de alta volatilidad y se contraen en calma</sub>",
      font = list(family = "Arial", size = 20)
    ),
    xaxis = list(
      title = "Fecha",
      rangeslider = list(visible = FALSE),
      showgrid = TRUE,
      gridcolor = 'rgba(200,200,200,0.1)'
    ),
    yaxis = list(
      title = "Precio (USD)",
      tickformat = "$.2f",
      gridcolor = 'rgba(200,200,200,0.1)'
    ),
    plot_bgcolor = '#ffffff',
    paper_bgcolor = '#f8f9fa',
    hovermode = 'x unified',
    legend = list(
      orientation = "h",
      x = 0.5,
      xanchor = "center",
      y = -0.15
    ),
    updatemenus = list(
      list(
        type = "buttons",
        direction = "right",
        x = 0.3,
        y = 1.15,
        buttons = list(
          list(
            method = "restyle",
            args = list("visible", c(TRUE, TRUE, TRUE)),
            label = "Mostrar Todo"
          ),
          list(
            method = "restyle",
            args = list("visible", c(TRUE, TRUE, FALSE)),
            label = "Ocultar Media"
          ),
          list(
            method = "restyle",
            args = list("visible", c(TRUE, FALSE, TRUE)),
            label = "Ocultar Precio"
          )
        )
      )
    )
  )

fig_bandas


```
La gr√°fica exhibe expansi√≥n consistente del ancho de las bandas conforme avanza el tiempo. Durante 2023, las bandas son extremadamente estrechas (¬±&#4-6 USD), reflejando volatilidad baja. A partir de enero de 2024, el ancho aumenta considerablemente, alcanzando ¬±&#10-12 USD para mediados de a√±o. En 2025, la expansi√≥n es dram√°tica, alcanzando un ancho m√°ximo de aproximadamente &#38 USD‚Äîel pico de volatilidad del per√≠odo.
Un patr√≥n notable es que la expansi√≥n de volatilidad acompa√±a la trayectoria ascendente del precio. En per√≠odos donde el precio se estanca (2023 con precios cercanos a &#85-95 USD), las bandas permanecen estrechas. Conforme el precio asciende hacia &#100-120 USD en 2024 y luego hacia &#140-190 USD en 2025, las bandas se expanden paralelamente. Esto sugiere que la volatilidad no es independiente del nivel de precio, sino que ambas dimensiones est√°n co-determinadas por factores macroecon√≥micos comunes que impulsan tanto la apreciaci√≥n como la incertidumbre en los precios de metales preciosos.

**Volatilidad comparada en rangos de tiempo**

La visualizaci√≥n de volatilidad en m√∫ltiples ventanas temporales (5 d√≠as, 20 d√≠as, 60 d√≠as y anual) permite caracterizar la estructura multiescalar de la variabilidad del ETF GLTR, identificando c√≥mo los shocks y la incertidumbre operan en distintos horizontes temporales.
```{r Volatilidad}
# Calcular volatilidad en diferentes ventanas temporales
comparador_volatilidad <- GLTR_df %>%
  arrange(Fecha) %>%
  mutate(
    Rendimiento = (Precio / lag(Precio) - 1) * 100
  ) %>%
  filter(!is.na(Rendimiento)) %>%
  mutate(
    Vol_5d = rollapply(Rendimiento, width = 5, FUN = sd, fill = NA, align = "right"),
    Vol_20d = rollapply(Rendimiento, width = 20, FUN = sd, fill = NA, align = "right"),
    Vol_60d = rollapply(Rendimiento, width = 60, FUN = sd, fill = NA, align = "right"),
    Vol_252d = rollapply(Rendimiento, width = 252, FUN = sd, fill = NA, align = "right")
  )

# Gr√°fico comparativo elegante
fig_comparativo <- plot_ly(comparador_volatilidad, x = ~Fecha) %>%
  # Volatilidad a 5 d√≠as (corto plazo)
  add_trace(
    y = ~Vol_5d,
    type = 'scatter',
    mode = 'lines',
    name = 'Vol 5 d√≠as',
    line = list(color = '#9fa0ff', width = 1.5),
    visible = TRUE,
    hovertemplate = 'Vol 5d: %{y:.2f}%<extra></extra>'
  ) %>%
  # Volatilidad a 20 d√≠as
  add_trace(
    y = ~Vol_20d,
    type = 'scatter',
    mode = 'lines',
    name = 'Vol 20 d√≠as',
    line = list(color = '#2E86AB', width = 2),
    visible = TRUE,
    hovertemplate = 'Vol 20d: %{y:.2f}%<extra></extra>'
  ) %>%
  # Volatilidad a 60 d√≠as
  add_trace(
    y = ~Vol_60d,
    type = 'scatter',
    mode = 'lines',
    name = 'Vol 60 d√≠as',
    line = list(color = '#ada7ff', width = 2.5),
    visible = TRUE,
    hovertemplate = 'Vol 60d: %{y:.2f}%<extra></extra>'
  ) %>%
  # Volatilidad a 252 d√≠as (anualizada)
  add_trace(
    y = ~Vol_252d,
    type = 'scatter',
    mode = 'lines',
    name = 'Vol Anual',
    line = list(color = '#757bc8', width = 3),
    visible = TRUE,
    hovertemplate = 'Vol Anual: %{y:.2f}%<extra></extra>'
  ) %>%
  layout(
    title = list(
      text = "<b>Comparativo de Volatilidad en Diferentes Ventanas Temporales</b>",
      font = list(family = "Arial", size = 20)
    ),
    xaxis = list(
      title = "Fecha",
      showgrid = TRUE,
      gridcolor = 'rgba(200,200,200,0.1)'
    ),
    yaxis = list(
      title = "Volatilidad (% desviaci√≥n est√°ndar)",
      tickformat = ".1f",
      gridcolor = 'rgba(200,200,200,0.1)'
    ),
    plot_bgcolor = '#ffffff',
    paper_bgcolor = '#f8f9fa',
    hovermode = 'x unified',
    legend = list(
      orientation = "h",
      x = 0.5,
      xanchor = "center",
      y = -0.15
    ),
    updatemenus = list(
      list(
        type = "buttons",
        direction = "right",
        x = 0.3,
        y = 1.15,
        showactive = TRUE,
        buttons = list(
          list(
            method = "restyle",
            args = list("visible", rep(TRUE, 4)),
            label = "Mostrar Todas"
          ),
          list(
            method = "restyle",
            args = list("visible", c(TRUE, FALSE, FALSE, FALSE)),
            label = "Solo 5 d√≠as"
          ),
          list(
            method = "restyle",
            args = list("visible", c(FALSE, TRUE, FALSE, FALSE)),
            label = "Solo 20 d√≠as"
          ),
          list(
            method = "restyle",
            args = list("visible", c(FALSE, FALSE, TRUE, FALSE)),
            label = "Solo 60 d√≠as"
          ),
          list(
            method = "restyle",
            args = list("visible", c(FALSE, FALSE, FALSE, TRUE)),
            label = "Solo Anual"
          )
        )
      )
    )
  )

# Mostrar el gr√°fico
fig_comparativo
```
La volatilidad de Corto Plazo exhibe fluctuaciones err√°ticas y de alta amplitud, oscilando entre aproximadamente 0.5% y 4.0%. Esta serie es notoriamente ruidosa, con m√∫ltiples picos transitorios que reflejan shocks diarios r√°pidamente absorbidos por el mercado.

La volatilidad de Mediano Plazo presenta un patr√≥n mucho m√°s suave que la de 5 d√≠as, oscilando t√≠picamente entre 0.8% y 2.0%. La l√≠nea azul filtra el ruido diario y captura la variabilidad subyacente de corto-mediano plazo, con picos menos frecuentes pero m√°s persistentes.

La volatilidad de Largo Plazo muestra la trayectoria m√°s suave y persistente, fluctuando entre aproximadamente 0.8% y 1.5%. Las oscilaciones en esta ventana son lentas y deliberadas, reflejando cambios en el ambiente macroecon√≥mico de mediano plazo.

La volatilidad Anual proporciona la perspectiva m√°s agregada, con una evoluci√≥n particularmente estable, comenzando cercana a 1.0% en 2023 y terminando cercana a 1.5-1.8% en 2025.

El an√°lisis descriptivo ha caracterizado la serie temporal del ETF GLTR a trav√©s de sus estad√≠sticas fundamentales, distribuci√≥n temporal, tendencia, estacionalidad y din√°mica de volatilidad en m√∫ltiples horizontes. Esta exploraci√≥n integral proporciona la base emp√≠rica necesaria para proceder con la especificaci√≥n y estimaci√≥n del modelo ARIMA.



# An√°lisis ARIMA
```{r datos}
# Configuraci√≥n de fechas - CAMBIAR SOLO AQU√ç
fecha_inicio_entrenamiento <- "2022-10-31"
fecha_fin_entrenamiento <- "2025-10-31"
fecha_inicio_prueba <- "2025-11-03"
fecha_fin_prueba <- "2025-11-21"  # ‚Üê FECHA FINAL AGREGADA

AccionesEX <- getSymbols("GLTR", src = "yahoo", auto.assign = FALSE, 
                         from = fecha_inicio_entrenamiento)
GLTR <- AccionesEX$GLTR.Close

Entrenamiento_GLTR <- window(GLTR, start = fecha_inicio_entrenamiento, end = fecha_fin_entrenamiento)
Prueba_GLTR <- window(GLTR, start = fecha_inicio_prueba, end = fecha_fin_prueba)

df_train_GLTR <- data.frame(
  Fecha = index(Entrenamiento_GLTR),
  Precio = as.numeric(Entrenamiento_GLTR),
  Conjunto = "Entrenamiento"
)

df_test_GLTR <- data.frame(
  Fecha = index(Prueba_GLTR),
  Precio = as.numeric(Prueba_GLTR),
  Conjunto = "Prueba"
)

df_completo_GLTR <- bind_rows(df_train_GLTR, df_test_GLTR)
fecha_corte_GLTR <- as.Date("2025-11-01")
```
```{r paleta}
gltr_pal <- list(
  primary = "#2C3E50",
  secondary = "#cbb2fe",
  tertiary = "#3498DB",
  positive = "#27AE60",
  negative = "#cbb2fe",
  text_dark = "#2C3E50",
  text_gray = "#7F8C8D",
  grid = "#BDC3C7"
)
```


Visualizaci√≥n de la Partici√≥n

La serie temporal de precios de cierre diarios de (GLTR) fue dividida en dos conjuntos mutuamente excluyentes siguiendo el enfoque de validaci√≥n cronol√≥gica la partici√≥n en entrenamiento y prueba permiten que el modelo se ajuste solo con informaci√≥n pasada y se eval√∫e con datos futuros.


```{r grafico-particion, fig.height=7}
ggplot(df_completo_GLTR, aes(x = Fecha, y = Precio)) +
  geom_ribbon(data = df_train_GLTR, 
              aes(ymin = min(df_completo_GLTR$Precio) * 0.95, ymax = Precio),
              fill = gltr_pal$primary, alpha = 0.08) +
  geom_ribbon(data = df_test_GLTR, 
              aes(ymin = min(df_completo_GLTR$Precio) * 0.95, ymax = Precio),
              fill = gltr_pal$secondary, alpha = 0.15) +
  geom_line(data = df_train_GLTR, color = gltr_pal$primary, linewidth = 0.9) +
  geom_line(data = df_test_GLTR, color = gltr_pal$secondary, linewidth = 1.1) +
  geom_vline(xintercept = fecha_corte_GLTR, 
             linetype = "dashed", color = gltr_pal$negative, linewidth = 0.8) +
  annotate("text", x = fecha_corte_GLTR, y = max(df_completo_GLTR$Precio) * 1.02,
           label = "Corte: 01-Nov-2025", hjust = -0.05, vjust = 0,
           color = gltr_pal$negative, fontface = "bold", size = 3.5) +
  annotate("label", 
           x = as.Date("2024-01-01"), 
           y = max(df_completo_GLTR$Precio) * 0.85,
           label = paste0("ENTRENAMIENTO\n", nrow(df_train_GLTR), " observaciones"),
           fill = gltr_pal$primary, color = "white", 
           fontface = "bold", size = 3.5, label.padding = unit(0.5, "lines")) +
  annotate("label", 
           x = max(df_test_GLTR$Fecha) - 1,
           y = min(df_completo_GLTR$Precio) * 1.15,
           label = paste0("PRUEBA\n", nrow(df_test_GLTR), " obs."),
           fill = gltr_pal$secondary, color = "white", 
           fontface = "bold", size = 3.2, label.padding = unit(0.4, "lines")) +
  scale_x_date(date_breaks = "4 months", date_labels = "%b %Y",
               expand = expansion(mult = c(0.02, 0.05))) +
  scale_y_continuous(labels = dollar_format(prefix = "$"),
                     expand = expansion(mult = c(0.05, 0.08))) +
  labs(
    title = "Partici√≥n de Datos: Entrenamiento vs Prueba",
    subtitle = "GLTR | Serie de precios de cierre diarios",
    x = NULL,
    y = "Precio de Cierre (USD)",
    caption = paste0("Fuente: Yahoo Finance | Per√≠odo: ", 
                     min(df_completo_GLTR$Fecha), " a ", max(df_completo_GLTR$Fecha))
  ) +
  theme_minimal(base_size = 12) +
  theme(
    plot.background = element_rect(fill = "transparent", color = NA),
    panel.background = element_rect(fill = "transparent", color = NA),
    plot.title = element_text(face = "bold", size = 16, color = gltr_pal$text_dark,
                              margin = margin(b = 5)),
    plot.subtitle = element_text(size = 11, color = gltr_pal$secondary,
                                 margin = margin(b = 15)),
    plot.caption = element_text(size = 9, color = gltr_pal$text_gray,
                                margin = margin(t = 15), hjust = 0),
    axis.title.y = element_text(face = "bold", size = 10, color = gltr_pal$text_gray),
    axis.text = element_text(size = 9, color = gltr_pal$text_gray),
    axis.text.x = element_text(angle = 45, hjust = 1),
    panel.grid.major = element_line(color = gltr_pal$grid, linetype = "dashed", linewidth = 0.4),
    panel.grid.minor = element_blank(),
    plot.margin = margin(20, 25, 15, 15)
  )
```
La Figura muestra la serie de precios de cierre diarios de GLTR entre el 31/10/2022 y el 21/11/2025 (aproximadamente 3 a√±os). La zona sombreada en gris corresponde al conjunto de entrenamiento, compuesto por 754 observaciones continuas. A partir de la l√≠nea discontinua roja definimos nuestro conjunto de prueba, formado por las 15 observaciones m√°s recientes, que se reservan exclusivamente para evaluar el desempe√±o predictivo del modelo.
El amplio historial de entrenamiento permite capturar la clara tendencia creciente y los patrones de variabilidad de la serie, mientras que la ventana de prueba, situada en el tramo de mayor volatilidad reciente, ofrece un escenario exigente para evaluar la precisi√≥n fuera de muestra del modelo ARIMA que se seleccionar√°.

## Analisis de estacionariedad
**Serie original- ACF**
La Figura muestra la funci√≥n de autocorrelaci√≥n (ACF) de la serie de precios de cierre de GLTR en niveles, usando solo los datos de entrenamiento. 


```{r stationarity-tests}
acf_data_GLTR <- acf(Entrenamiento_GLTR, lag.max = 30, plot = FALSE)

df_acf_GLTR <- data.frame(
  Lag = acf_data_GLTR$lag[-1], 
  ACF = acf_data_GLTR$acf[-1]
)

n_GLTR <- length(Entrenamiento_GLTR)
limite_sup_GLTR <- qnorm(0.975) / sqrt(n_GLTR)
limite_inf_GLTR <- -limite_sup_GLTR

ggplot(df_acf_GLTR, aes(x = Lag, y = ACF)) +
  geom_segment(aes(xend = Lag, yend = 0), 
               color = gltr_pal$primary, linewidth = 0.8) +
  geom_point(color = gltr_pal$primary, size = 2) +
  geom_hline(yintercept = limite_sup_GLTR, linetype = "dashed", 
             color = gltr_pal$secondary, linewidth = 0.7) +
  geom_hline(yintercept = limite_inf_GLTR, linetype = "dashed", 
             color = gltr_pal$secondary, linewidth = 0.7) +
  geom_hline(yintercept = 0, color = gltr_pal$text_gray, linewidth = 0.5) +
  annotate("rect", xmin = -Inf, xmax = Inf, 
           ymin = limite_inf_GLTR, ymax = limite_sup_GLTR,
           fill = gltr_pal$secondary, alpha = 0.1) +
  annotate("label", x = 20, y = 0.5,
           label = "Serie NO estacionaria",
           fill = gltr_pal$negative, color = "white",
           fontface = "bold", size = 3.5, label.padding = unit(0.5, "lines")) +
  scale_x_continuous(breaks = seq(0, 30, 5)) +
  scale_y_continuous(limits = c(-0.1, 1.05), breaks = seq(0, 1, 0.25)) +
  labs(
    title = "Funci√≥n de Autocorrelaci√≥n (ACF) - Serie en Niveles",
    subtitle = "GLTR: Precio de cierre | Datos de entrenamiento",
    x = "Rezago (Lag)",
    y = "Autocorrelaci√≥n",
    caption = "Bandas rojas: L√≠mites de significancia al 95%"
  ) +
  theme_minimal(base_size = 12) +
  theme(
    plot.background = element_rect(fill = "transparent", color = NA),
    panel.background = element_rect(fill = "transparent", color = NA),
    plot.title = element_text(face = "bold", size = 14, color = gltr_pal$text_dark),
    plot.subtitle = element_text(size = 10, color = gltr_pal$secondary),
    plot.caption = element_text(size = 9, color = gltr_pal$text_gray, hjust = 0),
    axis.title = element_text(face = "bold", size = 10, color = gltr_pal$text_gray),
    axis.text = element_text(size = 9, color = gltr_pal$text_gray),
    panel.grid.major = element_line(color = gltr_pal$grid, linetype = "dashed", linewidth = 0.4),
    panel.grid.minor = element_blank()
  )
```
La autocorrelaci√≥n en el rezago 1 es cercana a 1, las autocorrelaciones decrecen muy lentamente y se mantienen significativamente distintas de cero m√°s all√° del rezago 30 (todas por encima de las bandas rojas al 95%). Este patr√≥n indica que contamos con una serie no estacionaria con tendencia, donde los choques tienen efectos persistentes y la memoria de la serie es muy larga.  


**Test de Dickey-Fuller Aumentada (ADF)**

```{r Test de Dickey-Fuller Aumentada}
adf_resultado_GLTR <- adf.test(Entrenamiento_GLTR)

tabla_adf_GLTR <- data.frame(
  M√©trica = c("Estad√≠stico Dickey-Fuller", 
              "Orden de Rezagos (Lag)", 
              "P-valor",
              "Nivel de Significancia (Œ±)",
              "Hip√≥tesis Nula (H‚ÇÄ)",
              "Decisi√≥n"),
  
  Valor = c(round(adf_resultado_GLTR$statistic, 4),
            adf_resultado_GLTR$parameter,
            round(adf_resultado_GLTR$p.value, 4),
            "0.05",
            "Serie tiene ra√≠z unitaria",
            ifelse(adf_resultado_GLTR$p.value > 0.05, 
                   "No rechazar H‚ÇÄ", "Rechazar H‚ÇÄ")),
  
  Interpretaci√≥n = c("Valor del estad√≠stico de prueba",
                     "Rezagos incluidos en el test",
                     "Probabilidad bajo H‚ÇÄ",
                     "Umbral de decisi√≥n",
                     "La serie NO es estacionaria",
                     ifelse(adf_resultado_GLTR$p.value > 0.05,
                            "Serie NO estacionaria",
                            "Serie estacionaria"))
)

kable(tabla_adf_GLTR, 
      caption = "Prueba de Dickey-Fuller Aumentada (ADF) - Serie en Niveles GLTR",
      align = c("l", "c", "l")) %>%
  kable_styling(bootstrap_options = c("striped", "hover", "condensed"),
                full_width = FALSE,
                position = "center") %>%
  row_spec(3, bold = TRUE, color = "#757bc8") %>% 
  row_spec(6, bold = TRUE, background = "#fef3f2")
```
Bajo la hip√≥tesis nula, la serie tiene ra√≠z unitaria (no estacionaria). Como el p‚Äëvalor 0.984 > 0.05, no se rechaza $H0$. Por tanto, tanto la ACF como el test ADF coinciden en que la serie de precios en niveles NO es estacionaria y requiere la aplicaci√≥n de una primera diferenciaci√≥n antes de ajustar un modelo ARIMA, ya que, en su forma original, no cumple el supuesto de estacionariedad en media ni en autocovarianza.

**Diferenciaci√≥n**
Para abordar la no estacionariedad detectada en la serie en niveles, se aplic√≥ una diferenciaci√≥n de primer orden sobre el conjunto de entrenamiento:
```{r Diferenciacion}
GLTR_diff <- diff(Entrenamiento_GLTR) %>% na.omit()

GLTR_diff_df <- data.frame(
  Fecha = as.Date(time(GLTR_diff)),
  Cambio = as.numeric(GLTR_diff)
)

GLTR_diff_df$ID <- seq.int(nrow(GLTR_diff_df))
```
El gr√°fico de la serie diferenciada muestra ahora los cambios diarios en el precio de GLTR alrededor de un nivel aproximadamente constante, sin tendencia evidente. La variabilidad parece relativamente estable en la mayor parte del per√≠odo, aunque con algunos aumentos de volatilidad hacia el final. Este comportamiento respalda la elecci√≥n de $d = 1$ en el modelo ARIMA, ya que una sola diferenciaci√≥n elimina la tendencia de largo plazo observada en la serie original.

```{r grafico-diferenciado, fig.width=7, fig.height=5}
accumulate_by <- function(dat, var) {
  var <- lazyeval::f_eval(var, dat)
  lvls <- plotly:::getLevels(var)
  dats <- lapply(seq_along(lvls), function(x) {
    cbind(dat[var %in% lvls[seq(1, x)], ], frame = lvls[[x]])
  })
  dplyr::bind_rows(dats)
}

GLTR_diff_df <- GLTR_diff_df %>% accumulate_by(~ID)

fig_diff_animated <- plot_ly(
  data = GLTR_diff_df,
  x = ~Fecha,  
  y = ~Cambio,
  frame = ~frame,
  type = 'scatter',
  mode = 'lines',
  fill = 'tozeroy',
  fillcolor = 'rgba(0, 100, 200, 0.3)',
  line = list(color = 'rgb(0, 0, 0)', width = 1.5),
  text = ~paste(
    "Fecha: ", format(Fecha, "%d/%m/%Y"),
    "<br>Cambio: $", round(Cambio, 4)
  ),
  hoverinfo = 'text'
) %>%
  layout(
    title = list(
      text = "<b>Serie diferenciada GLTR</b>",
      font = list(size = 16, family = "Arial"),
      x = 0.5,
      xanchor = 'center'
    ),
    xaxis = list(
      title = "Fecha",
      range = c(min(GLTR_diff_df$Fecha), max(GLTR_diff_df$Fecha)),
      showgrid = TRUE,
      gridcolor = 'rgba(200, 200, 200, 0.3)',
      zeroline = FALSE
    ),
    yaxis = list(
      title = "Cambio en Precio",
      showgrid = TRUE,
      gridcolor = 'rgba(200, 200, 200, 0.3)',
      zeroline = TRUE,
      zerolinecolor = 'rgba(0, 0, 0, 0.3)',
      zerolinewidth = 1
    ),
    plot_bgcolor = '#f0f0f0',
    paper_bgcolor = 'white',
    hovermode = 'closest'
  ) %>%
  animation_opts(
    frame = 50,
    transition = 0,
    redraw = FALSE
  ) %>%
  animation_slider(
    currentvalue = list(
      prefix = "Fecha: ",
      font = list(color = "black")
    )
  )

fig_diff_animated

```
La Figura muestra la ACF de la serie diferenciada una vez. A diferencia de la serie en niveles, ahora contamos con casi todos los coeficientes de autocorrelaci√≥n caen dentro de las bandas verdes al 95%, no se observa un patr√≥n de decrecimiento lento ni correlaciones altas y persistentes. Solo aparecen unos pocos picos aislados, compatibles con ruido alrededor de cero. Este comportamiento es coherente con una serie aproximadamente estacionaria, por lo que la elecci√≥n de $d = 1$ resulta adecuada: una sola diferencia elimina la tendencia sin sobre diferenciar la serie.


**Test ADF - Serie Diferenciada**
```{r adf-diferenciada}
adf_diff_resultado_GLTR <- adf.test(GLTR_diff)

tabla_adf_diff_GLTR <- data.frame(
  M√©trica = c("Estad√≠stico Dickey-Fuller", 
              "Orden de Rezagos (Lag)", 
              "P-valor",
              "Nivel de Significancia (Œ±)",
              "Hip√≥tesis Nula (H‚ÇÄ)",
              "Decisi√≥n"),
  Valor = c(round(adf_diff_resultado_GLTR$statistic, 4),
            adf_diff_resultado_GLTR$parameter,
            round(adf_diff_resultado_GLTR$p.value, 4),
            "0.05",
            "Serie tiene ra√≠z unitaria",
            ifelse(adf_diff_resultado_GLTR$p.value > 0.05, 
                   "No rechazar H‚ÇÄ", "Rechazar H‚ÇÄ")),
  Interpretaci√≥n = c("Valor del estad√≠stico de prueba",
                     "Rezagos incluidos en el test",
                     "Probabilidad bajo H‚ÇÄ",
                     "Umbral de decisi√≥n",
                     "La serie NO es estacionaria",
                     ifelse(adf_diff_resultado_GLTR$p.value > 0.05,
                            "Serie NO estacionaria",
                            "Serie estacionaria"))
)

kable(tabla_adf_diff_GLTR, 
      caption = "Prueba de Dickey-Fuller Aumentada (ADF) - Serie Diferenciada GLTR",
      align = c("l", "c", "l")) %>%
  kable_styling(bootstrap_options = c("striped", "hover", "condensed"),
                full_width = FALSE,
                position = "center") %>%
  row_spec(3, bold = TRUE, color = "#957fef") %>% 
  row_spec(6, bold = TRUE, background = "#efd9ce")
```

La prueba ADF aplicada a la serie diferenciada mostr√≥ un estad√≠stico de $‚àí10.0227$, con 9 rezagos y un valor p de $0.01$, lo que nos indica que podemos rechazar $(H0)$ y concluir que la serie diferenciada es estacionaria. Esto coincide con la ACF, confirmando que con $(d = 1)$ se logra la estacionariedad necesaria para dar paso a la identificaci√≥n de  los valores adecuados de $(p)$ y $(q)$.

En la serie ya diferenciada el ACF no muestra picos grandes ni un patr√≥n de corte claro; las autocorrelaciones son peque√±as y la mayor√≠a cae dentro de las bandas. A su vez, en el PACF aparecen algunos picos algo m√°s notorios en rezagos bajos y medios (por ejemplo, alrededor de lag 3 y 24), pero ninguno domina claramente. Este comportamiento sugiere que no existe una estructura AR o MA ‚Äúpura‚Äù, es decir las dependencias son d√©biles y se dispersan en varios rezagos. Por ello, resulta m√°s adecuado probar modelos ARIMA de bajo orden que suelen capturar bien la din√°mica residual de series diferenciadas con correlaciones d√©biles y reducen el riesgo de sobreestimar la complejidad del modelo.


## Identificaci√≥n del modelo

A partir de la serie ya diferenciada $(d=1)$, se analizan las funciones ACF y PACF para sugerir √≥rdenes tentativos de los componentes $AR (p)$ y $MA (q)$.
```{r funcion-acf-pacf}
crear_grafico_acf_pacf <- function(serie, titulo_serie = "GLTR", lag_max = NULL) {
  
  acf_data <- acf(serie, plot = FALSE, lag.max = lag_max)
  pacf_data <- pacf(serie, plot = FALSE, lag.max = lag_max)
  
  acf_df <- data.frame(
    lag = as.numeric(acf_data$lag)[-1], 
    acf = as.numeric(acf_data$acf)[-1]
  )
  
  pacf_df <- data.frame(
    lag = as.numeric(pacf_data$lag), 
    pacf = as.numeric(pacf_data$acf)
  )
  
  conf_level <- qnorm((1 + 0.95)/2)/sqrt(acf_data$n.used)
  
  y_max <- max(c(abs(acf_df$acf), abs(pacf_df$pacf), conf_level)) * 1.2
  
  # GR√ÅFICO ACF
  p_acf <- ggplot(acf_df, aes(x = lag, y = acf)) +
    geom_bar(stat = "identity", 
             width = 0.7,
             fill = ifelse(acf_df$acf > 0, "#2196F3", "#FF5252"),
             color = NA,
             alpha = 0.8) +
    geom_hline(yintercept = conf_level, 
               color = "#757575", 
               linetype = "dashed", 
               linewidth = 0.5,
               alpha = 0.7) +
    geom_hline(yintercept = -conf_level, 
               color = "#757575", 
               linetype = "dashed", 
               linewidth = 0.5,
               alpha = 0.7) +
    geom_hline(yintercept = 0, 
               color = "#212121", 
               linewidth = 0.3) +
    annotate("rect",
             xmin = -Inf, xmax = Inf,
             ymin = -conf_level, ymax = conf_level,
             fill = "#E8F5E9",
             alpha = 0.2) +
    geom_text(data = subset(acf_df, abs(acf) > conf_level),
              aes(label = round(acf, 2)),
              vjust = ifelse(subset(acf_df, abs(acf) > conf_level)$acf > 0, -0.8, 1.2),
              size = 3.2,
              fontface = "bold",
              color = "#212121") +
    labs(
      title = "AUTOCORRELACI√ìN (ACF)",
      subtitle = paste("Serie diferenciada:", titulo_serie),
      x = "Desfase (Lags)",
      y = "Autocorrelaci√≥n",
      caption = paste(" ")
    ) +
    scale_x_continuous(breaks = scales::pretty_breaks(n = min(20, max(acf_df$lag)))) +
    scale_y_continuous(limits = c(-y_max, y_max),
                       breaks = scales::pretty_breaks(n = 8)) +
    theme_minimal(base_size = 12) +
    theme(
      panel.background = element_rect(fill = "white", color = NA),
      plot.background = element_rect(fill = "white", color = NA),
      panel.border = element_rect(color = "#E0E0E0", fill = NA, linewidth = 0.5),
      plot.title = element_text(
        face = "bold",
        size = 14,
        color = "#0D47A1",
        hjust = 0,
        margin = margin(b = 8)
      ),
      plot.subtitle = element_text(
        size = 11,
        color = "#546E7A",
        hjust = 0,
        margin = margin(b = 15)
      ),
      axis.title = element_text(
        size = 11,
        color = "#37474F",
        face = "bold"
      ),
      axis.text = element_text(
        size = 10,
        color = "#546E7A"
      ),
      panel.grid.major.x = element_blank(),
      panel.grid.minor.x = element_blank(),
      panel.grid.major.y = element_line(color = "#F5F5F5", linewidth = 0.5),
      panel.grid.minor.y = element_blank(),
      plot.margin = margin(15, 20, 15, 15)
    )
  
  # GR√ÅFICO PACF
  p_pacf <- ggplot(pacf_df, aes(x = lag, y = pacf)) +
    geom_bar(stat = "identity", 
             width = 0.7,
             fill = ifelse(pacf_df$pacf > 0, "#4CAF50", "#FF9800"),
             color = NA,
             alpha = 0.8) +
    geom_hline(yintercept = conf_level, 
               color = "#757575", 
               linetype = "dashed", 
               linewidth = 0.5,
               alpha = 0.7) +
    geom_hline(yintercept = -conf_level, 
               color = "#757575", 
               linetype = "dashed", 
               linewidth = 0.5,
               alpha = 0.7) +
    geom_hline(yintercept = 0, 
               color = "#212121", 
               linewidth = 0.3) +
    annotate("rect",
             xmin = -Inf, xmax = Inf,
             ymin = -conf_level, ymax = conf_level,
             fill = "#F3E5F5",
             alpha = 0.2) +
    geom_text(data = subset(pacf_df, abs(pacf) > conf_level),
              aes(label = round(pacf, 2)),
              vjust = ifelse(subset(pacf_df, abs(pacf) > conf_level)$pacf > 0, -0.8, 1.2),
              size = 3.2,
              fontface = "bold",
              color = "#212121") +
    labs(
      title = "AUTOCORRELACI√ìN PARCIAL (PACF)",
      subtitle = paste("Serie diferenciada:", titulo_serie),
      x = "Desfase (Lags)",
      y = "Autocorrelaci√≥n Parcial",
      caption = paste(" ", 
                      format(Sys.Date(), "%d/%m/%Y"))
    ) +
    scale_x_continuous(breaks = scales::pretty_breaks(n = min(20, max(pacf_df$lag)))) +
    scale_y_continuous(limits = c(-y_max, y_max),
                       breaks = scales::pretty_breaks(n = 8)) +
    theme_minimal(base_size = 12) +
    theme(
      panel.background = element_rect(fill = "white", color = NA),
      plot.background = element_rect(fill = "white", color = NA),
      panel.border = element_rect(color = "#E0E0E0", fill = NA, linewidth = 0.5),
      plot.title = element_text(
        face = "bold",
        size = 14,
        color = "#7B1FA2",
        hjust = 0,
        margin = margin(b = 8)
      ),
      plot.subtitle = element_text(
        size = 11,
        color = "#546E7A",
        hjust = 0,
        margin = margin(b = 15)
      ),
      axis.title = element_text(
        size = 11,
        color = "#37474F",
        face = "bold"
      ),
      axis.text = element_text(
        size = 10,
        color = "#546E7A"
      ),
      panel.grid.major.x = element_blank(),
      panel.grid.minor.x = element_blank(),
      panel.grid.major.y = element_line(color = "#F5F5F5", linewidth = 0.5),
      panel.grid.minor.y = element_blank(),
      plot.margin = margin(15, 20, 15, 15)
    )
  
  return(list(ACF = p_acf, PACF = p_pacf))
}
```
```{r graficos-acf-pacf, fig.width=12, fig.height=6}
graficos <- crear_grafico_acf_pacf(
  serie = GLTR_diff,
  titulo_serie = "GLTR (Diferenciada d=1)",
  lag_max = 36
)

panel_completo <- grid.arrange(
  graficos$ACF,
  graficos$PACF,
  nrow = 1,
  top = textGrob(
    "",
    gp = gpar(fontsize = 18, fontface = "bold", col = "#0D47A1"),
    vjust = 1.5
  ),
  bottom = textGrob(
    paste("An√°lisis generado:", Sys.Date(), "| M√©todo: Diferenciaci√≥n (d=1)"),
    gp = gpar(fontsize = 10, col = "#78909C"),
    vjust = -0.5
  ),
  padding = unit(2, "cm")
)

```

La ausencia de picos muy dominantes y la presencia de algunas autocorrelaciones moderadas en rezagos bajos motivan la consideraci√≥n de modelos de bajo a mediano orden, combinando t√©rminos $AR$ y $MA$.

Con base en este an√°lisis visual y en el procedimiento automatizado de auto.arima(), se defini√≥ el siguiente conjunto de modelos candidatos:
```{r modelos}
Modelo_GLTR_auto <- auto.arima(Entrenamiento_GLTR)
Modelo_GLTR_1 <- Arima(Entrenamiento_GLTR, order = c(3, 1, 4))
Modelo_GLTR_2 <- Arima(Entrenamiento_GLTR, order = c(1, 1, 1))
Modelo_GLTR_3 <- Arima(Entrenamiento_GLTR, order = c(2, 1, 4))
Modelo_GLTR_4 <- Arima(Entrenamiento_GLTR, order = c(4, 1, 4))
```
```{r modelos-t}
# Crear el dataframe
datos_modelos <- data.frame(
  `Etiqueta del Modelo` = c(
    "Modelo_GLTR_auto",
    "Modelo_GLTR_1", 
    "Modelo_GLTR_2",
    "Modelo_GLTR_3",
    "Modelo_GLTR_4"
  ),
  `Especificaci√≥n ARIMA` = c(
    "ARIMA(p, d, q) elegido por auto.arima()",
    "ARIMA(3, 1, 4)",
    "ARIMA(1, 1, 1)",
    "ARIMA(2, 1, 4)",
    "ARIMA(4, 1, 4)"
  ),
  `Motivo de Elecci√≥n` = c(
    "B√∫squeda autom√°tica exhaustiva que minimiza AICc. Sirve como referencia objetiva y verifica si el algoritmo identifica estructuras que no son evidentes en ACF/PACF manual.",
    "Estructura ARMA balanceada sugerida por picos moderados en PACF (rezagos 1‚Äì3) y ACF (rezagos 1‚Äì4) de la serie diferenciada. Permite capturar din√°micas de mediano plazo pero puede llegar a sobreparametrizar.",
    "Modelo parsimonioso de bajo orden, ideal como referencia simple. Consistente con ACF/PACF sin picos dominantes; √∫til para comparar si modelos m√°s complejos justifican el costo de parsimonia.",
    "Variante intermedia que aumenta ligeramente el orden MA respecto al AR, sugerida por ligeras persistencias en ACF a rezagos altos. Permite evaluar si componentes MA adicionales mejoran el ajuste.",
    "Modelo m√°s complejo que captura estructuras AR y MA de mayor orden, √∫til para verificar si autocorrelaciones parciales en rezagos 3‚Äì4 son significativas o solo ruido. Sirve como benchmark de m√°xima complejidad razonable."
  ),
  check.names = FALSE
)

# Crear tabla profesional con gt
tabla_modelos <- datos_modelos %>%
  gt() %>%
  tab_header(
    title = md("**Tabla 1: Modelos ARIMA Considerados para la Serie GLTR**"),
    subtitle = "Especificaciones y justificaci√≥n de cada configuraci√≥n"
  ) %>%
  cols_label(
    `Etiqueta del Modelo` = md("**Etiqueta del Modelo**"),
    `Especificaci√≥n ARIMA` = md("**Especificaci√≥n ARIMA**"),
    `Motivo de Elecci√≥n` = md("**Motivo de Elecci√≥n**")
  ) %>%
  tab_style(
    style = cell_text(
      font = "Segoe UI",
      size = "small",
      weight = "normal"
    ),
    locations = cells_body()
  ) %>%
  tab_style(
    style = cell_text(
      font = "Segoe UI",
      size = "medium",
      weight = "bold"
    ),
    locations = cells_column_labels()
  ) %>%
  tab_style(
    style = cell_fill(color = "#f8f9fa"),
    locations = cells_body(rows = seq(1, nrow(datos_modelos), by = 2))
  ) %>%
  tab_style(
    style = cell_borders(
      sides = c("top", "bottom"),
      color = "#dee2e6",
      weight = px(1)
    ),
    locations = cells_body()
  ) %>%
  cols_width(
    `Etiqueta del Modelo` ~ px(150),
    `Especificaci√≥n ARIMA` ~ px(200),
    `Motivo de Elecci√≥n` ~ px(500)
  ) %>%
  tab_options(
    table.font.names = "Segoe UI",
    table.font.size = px(13),
    heading.title.font.size = px(20),
    heading.subtitle.font.size = px(15),
    heading.align = "left",
    table.width = pct(100),
    column_labels.border.top.color = "black",
    column_labels.border.top.width = px(2),
    column_labels.border.bottom.color = "black",
    column_labels.border.bottom.width = px(2),
    table_body.hlines.color = "#f0f0f0",
    source_notes.font.size = px(11)
  ) %>%
  tab_source_note(
    source_note = md("**Nota:** Todos los modelos incluyen diferenciaci√≥n (d=1) para asegurar estacionariedad de la serie.")
  )

# IMPORTANTE: Mostrar la tabla
tabla_modelos
```


# Estimaci√≥n y comparaci√≥n de modelos
Estos modelos ser√°n comparados en la siguiente secci√≥n usando criterios de informaci√≥n $(AIC, AICc, BIC)$ y m√©tricas de precisi√≥n.
```{r t-modelos}
tabla_modelos_GLTR <- data.frame(
  Modelo = c('Auto-ARIMA', 'ARIMA(3,1,4)', 'ARIMA(1,1,1)', 'ARIMA(2,1,4)', 'ARIMA(4,1,4)'),
  AIC = round(c(Modelo_GLTR_auto$aic, Modelo_GLTR_1$aic, Modelo_GLTR_2$aic, 
                Modelo_GLTR_3$aic, Modelo_GLTR_4$aic), 2),
  AICc = round(c(Modelo_GLTR_auto$aicc, Modelo_GLTR_1$aicc, Modelo_GLTR_2$aicc, 
                 Modelo_GLTR_3$aicc, Modelo_GLTR_4$aicc), 2),
  BIC = round(c(Modelo_GLTR_auto$bic, Modelo_GLTR_1$bic, Modelo_GLTR_2$bic, 
                Modelo_GLTR_3$bic, Modelo_GLTR_4$bic), 2)
) %>% arrange(AICc)

kable(tabla_modelos_GLTR, 
      caption = "Comparaci√≥n de Modelos ARIMA - Criterios de Informaci√≥n",
      align = c("l", "c", "c", "c")) %>%
  kable_styling(bootstrap_options = c("striped", "hover", "condensed"),
                full_width = FALSE,
                position = "center") %>%
  row_spec(1, bold = TRUE, background = "#efd9ce")
```
La tabla resume los valores de $AIC, AICc$ y $BIC$ para los cinco modelos ARIMA estimados. Aunque el modelo Auto‚ÄëARIMA presenta los menores $AIC y AICc (2637.30 y 2637.41)$, y tambi√©n el menor $BIC (2665.04)$, la comparaci√≥n con los modelos manuales permite ver que ninguno logra acercarse lo suficiente como para ser competitivo. 
```{r metricas-precision}
accuracy_auto <- accuracy(Modelo_GLTR_auto)
accuracy_1 <- accuracy(Modelo_GLTR_1)
accuracy_2 <- accuracy(Modelo_GLTR_2)
accuracy_3 <- accuracy(Modelo_GLTR_3)
accuracy_4 <- accuracy(Modelo_GLTR_4)

tabla_accuracy_GLTR <- data.frame(
  Modelo = c('Auto-ARIMA', 'ARIMA(3,1,4)', 'ARIMA(1,1,1)', 'ARIMA(2,1,4)', 'ARIMA(4,1,4)'),
  ME = round(c(accuracy_auto[1], accuracy_1[1], accuracy_2[1], accuracy_3[1], accuracy_4[1]), 4),
  RMSE = round(c(accuracy_auto[2], accuracy_1[2], accuracy_2[2], accuracy_3[2], accuracy_4[2]), 4),
  MAE = round(c(accuracy_auto[3], accuracy_1[3], accuracy_2[3], accuracy_3[3], accuracy_4[3]), 4),
  MAPE = round(c(accuracy_auto[5], accuracy_1[5], accuracy_2[5], accuracy_3[5], accuracy_4[5]), 2)
)

kable(tabla_accuracy_GLTR, 
      caption = "M√©tricas de Precisi√≥n - Modelos ARIMA GLTR",
      align = c("l", "c", "c", "c", "c")) %>%
  kable_styling(bootstrap_options = c("striped", "hover", "condensed"),
                full_width = FALSE,
                position = "center")
```
La tabla compara las m√©tricas de precisi√≥n para los cinco modelos los cuales presentan un rendimiento muy similar, con MAPE alrededor de 0.9% y diferencias peque√±as en los errores absolutos. Las diferencias en MAE son m√≠nimas $(0.9817$ vs $0.983x)$, aun as√≠, el Auto-ARIMA obtiene los mejores valores de RMSE y MAE, adem√°s de un sesgo casi nulo, mientras que los dem√°s muestran un sesgo positivo m√°s evidente. Esto indica que, aunque todos los modelos ajustan bien, el Auto-ARIMA se considera el modelo con mejor capacidad de ajuste, aunque la ventaja sobre los modelos manuales es moderada.

En consecuencia, el auto.arima  no solo es el m√°s parsimonioso dentro de su complejidad, sino tambi√©n el que captura mejor la estructura de la serie. Por ello se selecciona como el modelo principal para los diagn√≥sticos de residuos para confirmar su validez final.

# Selecci√≥n del Modelo

Para evaluar si el modelo ARIMA seleccionado cumple con los supuestos fundamentales, se analizan los gr√°ficos de diagn√≥stico de residuos. 

**Diagn√≥stico de Residuales**

```{r residuales-tiempo, fig.height=7}
residuos_auto <- residuals(Modelo_GLTR_auto)

residuos_df <- data.frame(
  tiempo = time(residuos_auto),
  residuales = as.numeric(residuos_auto)
)

sd_resid <- sd(residuos_df$residuales, na.rm = TRUE)
residuos_df$extremo <- abs(residuos_df$residuales) > 2 * sd_resid
residuos_df$muy_extremo <- abs(residuos_df$residuales) > 3 * sd_resid

ggplot(residuos_df, aes(x = tiempo, y = residuales)) +
  geom_ribbon(
    aes(ymin = -1.96 * sd_resid, 
        ymax = 1.96 * sd_resid),
    fill = "#E8F4F8",
    alpha = 0.3
  ) +
  geom_line(color = "#1E88E5", linewidth = 0.8) +
  geom_hline(yintercept = 0, color = "#2E5A87", linetype = "solid", 
             linewidth = 1.2, alpha = 0.8) +
  geom_smooth(method = "loess", se = TRUE, color = "#957fef", 
              fill = "#7161ef", alpha = 0.3, linewidth = 0.8) +
  geom_point(
    data = residuos_df[residuos_df$extremo, ],
    aes(x = tiempo, y = residuales),
    color = "blue",
    size = 2,
    alpha = 0.7
  ) +
  geom_text(
    data = residuos_df[residuos_df$muy_extremo, ],
    aes(x = tiempo, y = residuales, label = round(residuales, 2)),
    vjust = -1,
    size = 3,
    color = "#8187dc"
  ) +
  labs(
    title = "An√°lisis de Residuales - Modelo Auto ARIMA",
    subtitle = paste("Especificaci√≥n del modelo: ARIMA(", 
                     paste(arimaorder(Modelo_GLTR_auto), collapse = ","), ")"),
    x = "Per√≠odo Temporal",
    y = "Valor de los Residuales",
    caption = "Fuente: An√°lisis propio | L√≠nea naranja: tendencia LOESS"
  ) +
  theme_minimal(base_size = 11) +
  theme(
    plot.title = element_text(
      face = "bold", 
      size = 16,
      color = "#1E3A5F",
      hjust = 0.5,
      margin = margin(b = 10)
    ),
    plot.subtitle = element_text(
      size = 12,
      color = "#4A4A4A",
      hjust = 0.5,
      margin = margin(b = 15)
    ),
    axis.title = element_text(
      face = "bold",
      size = 11,
      color = "#333333"
    ),
    panel.grid.major = element_line(
      color = "#F0F0F0",
      linewidth = 0.5
    ),
    panel.grid.minor = element_blank(),
    panel.background = element_rect(fill = "#FAFAFA", color = NA),
    plot.background = element_rect(fill = "white", color = NA),
    plot.margin = margin(20, 30, 20, 30)
  )
```
Los residuos se comportan adecuadamente: oscilan alrededor de cero sin tendencia, lo que indica ausencia de sesgo, y no muestran patrones evidentes, por lo que el modelo captura bien la estructura temporal principal. Sin embargo, en conjunto, se comportan en general como ruido blanco alrededor de cero, lo que respalda la adecuaci√≥n del modelo. No obstante, la presencia de algunos outliers sugiere episodios de volatilidad no explicados por el ARIMA, algo esperable en datos financieros.

**Histograma de Residuales**

```{r histograma-residuales, fig.height=7}
residuales_valores <- as.numeric(residuos_auto)
residuales_df <- data.frame(Residuales = residuales_valores)

media_res <- mean(residuales_valores)
sd_res <- sd(residuales_valores)
n_res <- length(residuales_valores)

rango_residuales <- range(residuales_valores)
x_lim_inf <- rango_residuales[1] - 0.1 * diff(rango_residuales)
x_lim_sup <- rango_residuales[2] + 0.1 * diff(rango_residuales)

dens <- density(residuales_valores)
max_densidad <- max(dens$y)
y_lim_sup <- max_densidad * 1.15

ggplot(residuales_df, aes(x = Residuales)) +
  geom_histogram(
    aes(y = after_stat(density)),
    bins = 30,
    fill = "#2E5A87",
    alpha = 0.7,
    color = "white",
    size = 0.3
  ) +
  geom_density(
    color = "#efd9ce",
    linewidth = 1.2,
    adjust = 1.2
  ) +
  stat_function(
    fun = dnorm,
    args = list(mean = media_res, sd = sd_res),
    color = "#009E73",
    linewidth = 1.2,
    linetype = "dashed"
  ) +
  geom_vline(
    xintercept = media_res,
    color = "#333333",
    linetype = "solid",
    linewidth = 1,
    alpha = 0.8
  ) +
  geom_vline(
    xintercept = c(media_res - sd_res, media_res + sd_res),
    color = "#666666",
    linetype = "dashed",
    linewidth = 0.6,
    alpha = 0.6
  ) +
  annotate(
    "text",
    x = media_res,
    y = y_lim_sup * 0.95,
    label = paste("Media =", round(media_res, 3)),
    hjust = ifelse(media_res > mean(c(x_lim_inf, x_lim_sup)), 1.1, -0.1),
    size = 3.5,
    color = "#333333",
    fontface = "bold"
  ) +
  coord_cartesian(
    xlim = c(x_lim_inf, x_lim_sup),
    ylim = c(0, y_lim_sup)
  ) +
  labs(
    title = "Distribuci√≥n de Residuales - Modelo Auto ARIMA",
    subtitle = paste(
      "Media =", round(media_res, 4), 
      "| SD =", round(sd_res, 4),
      "| n =", format(n_res, big.mark = ",")
    ),
    x = "Valor de los Residuales",
    y = "Densidad",
    caption = "L√≠neas: Media (negra s√≥lida), ¬±1 SD (gris discontinua), ¬±2 SD (gris punteada)"
  ) +
  theme_minimal(base_size = 12) +
  theme(
    plot.title = element_text(
      face = "bold", 
      size = 16,
      hjust = 0.5,
      margin = margin(b = 10)
    ),
    plot.subtitle = element_text(
      size = 12,
      color = "gray40",
      hjust = 0.5,
      margin = margin(b = 15)
    ),
    axis.title = element_text(face = "bold", size = 11),
    panel.grid.major = element_line(color = "gray90", size = 0.3),
    panel.grid.minor = element_blank(),
    panel.background = element_rect(fill = "white", color = NA),
    plot.background = element_rect(fill = "white", color = NA)
  )
```
En segundo lugar, se analiza la distribuci√≥n de los residuos del modelo Auto‚ÄëARIMA mediante un histograma con curvas de densidad ajustada y normal te√≥rica. Este gr√°fico permite evaluar si los errores se concentran alrededor de cero y si su forma es aproximadamente sim√©trica y en campana, como se espera bajo el supuesto de normalidad residual

**ACF de Residuales**

```{r acf-residuales}
acf_residuos <- acf(residuos_auto, lag.max = 40, plot = FALSE)

df_acf_residuos <- data.frame(
  Lag = acf_residuos$lag[-1], 
  ACF = acf_residuos$acf[-1]
)

n_residuos <- length(residuos_auto)
limite_sup_residuos <- qnorm(0.975) / sqrt(n_residuos)
limite_inf_residuos <- -limite_sup_residuos

ggplot(df_acf_residuos, aes(x = Lag, y = ACF)) +
  annotate("rect", 
           xmin = -Inf, xmax = Inf, 
           ymin = limite_inf_residuos, ymax = limite_sup_residuos,
           fill = "#E63946", 
           alpha = 0.05) +
  geom_segment(aes(xend = Lag, yend = 0), 
               color = "#2E86AB", 
               linewidth = 0.9, 
               lineend = "round") +
  geom_point(color = "#2E86AB", 
             fill = "#2E86AB", 
             size = 2.5, 
             shape = 21, 
             stroke = 0.5) +
  geom_hline(yintercept = c(limite_sup_residuos, limite_inf_residuos), 
             linetype = "dashed", 
             color = "#E63946", 
             linewidth = 0.6) +
  geom_hline(yintercept = 0, 
             color = "#4A4A4A", 
             linewidth = 0.4) +
  scale_x_continuous(breaks = seq(0, 40, by = 5),
                     expand = expansion(mult = c(0.02, 0.02))) +
  scale_y_continuous(limits = c(-0.35, 0.35),
                     breaks = seq(-0.3, 0.3, by = 0.1),
                     expand = expansion(mult = c(0, 0.05))) +
  labs(
    title = "FUNCI√ìN DE AUTOCORRELACI√ìN DE RESIDUALES",
    subtitle = "Modelo Auto ARIMA | An√°lisis de independencia de residuales",
    x = "Rezago (Lag)",
    y = "Coeficiente de Autocorrelaci√≥n (ACF)",
    caption = paste0(
      "Intervalo de confianza del 95% (¬±", 
      round(limite_sup_residuos, 3), 
      ") | n = ", 
      format(n_residuos, big.mark = ",")
    )
  ) +
  theme_minimal(base_size = 12) +
  theme(
    plot.background = element_rect(fill = "#F8F9FA", color = NA),
    panel.background = element_rect(fill = "white", color = NA),
    plot.margin = margin(20, 25, 20, 25),
    plot.title = element_text(
      face = "bold", 
      size = 16, 
      color = "#212529",
      hjust = 0.5,
      margin = margin(b = 8)
    ),
    panel.grid.major = element_line(
      color = "#E9ECEF", 
      linewidth = 0.3
    ),
    panel.grid.minor = element_blank()
  )
```

Al examinar la ACF de los residuos, se observa un comportamiento claramente consistente con lo esperado para un buen modelo ARIMA. La mayor√≠a de los coeficientes se mantienen dentro de las bandas de confianza y no emerge ning√∫n patr√≥n definido que sugiera dependencia temporal persistente. Los pocos rezagos que se aproximan a los l√≠mites lo hacen de manera aislada y con poca magnitud. 

**Prueba de Ljung-Box**

```{r ljung-box}
ljung_box_result <- Box.test(residuals(Modelo_GLTR_auto), lag = 10, type = "Ljung-Box")

tabla_ljung_box <- data.frame(
  Estad√≠stico = c("X-squared", "Grados de libertad", "P-valor", "Decisi√≥n"),
  Valor = c(round(ljung_box_result$statistic, 4),
            ljung_box_result$parameter,
            round(ljung_box_result$p.value, 4),
            ifelse(ljung_box_result$p.value > 0.05, 
                   "No rechazar H‚ÇÄ: Residuos = Ruido Blanco ‚úì", 
                   "Rechazar H‚ÇÄ: Residuos ‚â† Ruido Blanco ‚úó"))
)

kable(tabla_ljung_box, 
      caption = "Prueba de Ljung-Box - Validaci√≥n de Residuos",
      align = c("l", "c")) %>%
  kable_styling(bootstrap_options = c("striped", "hover", "condensed"),
                full_width = FALSE,
                position = "center") %>%
  row_spec(4, bold = TRUE, background = "#d5f4e6")
```
Finalmente, se aplic√≥ la prueba de Ljung‚ÄëBox para evaluar la presencia de autocorrelaci√≥n conjunta en los residuos. El estad√≠stico de contraste fue  $X2 =4.5822$ con 10 grados de libertad y un valor p de $0.9173$. Dado que este valor p es muy superior al nivel de significancia habitual $(Œ± =0.05)$, no se rechaza la hip√≥tesis nula de que los residuos se comportan como ruido blanco.
En conjunto, los distintos an√°lisis confirman que el modelo ARIMA seleccionado es adecuado, los residuos se mantienen alrededor de cero sin patrones sistem√°ticos, muestran una distribuci√≥n razonablemente sim√©trica y su ACF indica comportamiento de ruido blanco. Aunque aparecen algunos outliers t√≠picos de la volatilidad financiera, estos no comprometen el ajuste general, adicionalmente la prueba de Ljung-Box respalda esta conclusi√≥n al no evidenciar autocorrelaci√≥n conjunta $(p = 0.9173)$. En s√≠ntesis, el modelo cumple razonablemente con los supuestos fundamentales y puede considerarse estad√≠sticamente consistente para fines de pron√≥stico. 

## Pron√≥stico y Evaluaci√≥n

**Generaci√≥n del Pron√≥stico**

```{r pronostico, fig.height=7}
h_value <- length(Prueba_GLTR)
pronostico_GLTR <- Modelo_GLTR_auto %>% 
  forecast(h = h_value, level = 0.95)

pronostico_GLTR %>% 
  autoplot(include = 100) +
  labs(
    title = "Pron√≥stico del Precio de Cierre GLTR",
    subtitle = paste0("Modelo: ", Modelo_GLTR_auto, " | Intervalo de Confianza: 95%"),
    x = "Fecha",
    y = "Precio de Cierre (USD)",
    caption = paste0("Horizonte de pron√≥stico: ", h_value, " observaciones")
  ) +
  theme_minimal(base_size = 12) +
  theme(
    plot.title = element_text(
      face = "bold",
      size = 16,
      hjust = 0.5,
      margin = margin(b = 5),
      color = "#2C3E50"
    ),
    plot.subtitle = element_text(
      size = 11,
      hjust = 0.5,
      margin = margin(b = 15),
      color = "#7F8C8D"
    ),
    axis.title.x = element_text(
      face = "bold",
      size = 12,
      margin = margin(t = 10),
      color = "#34495E"
    ),
    axis.title.y = element_text(
      face = "bold",
      size = 12,
      margin = margin(r = 10),
      color = "#34495E"
    ),
    panel.grid.major = element_line(color = "#ECF0F1", linewidth = 0.5),
    panel.grid.minor = element_line(color = "#F8F9F9", linewidth = 0.3),
    legend.position = "bottom",
    plot.margin = margin(20, 20, 15, 20)
  ) +
  scale_color_manual(
    values = c("Data" = "#3498DB", "Forecast" = "#E74C3C"),
    name = "Serie"
  ) +
  scale_fill_manual(
    values = c("95%" = alpha("#E74C3C", 0.2)),
    name = "Intervalo"
  )
```
El gr√°fico muestra el pron√≥stico del precio de cierre de GLTR a partir del modelo ARIMA(2,1,2) con drift para un horizonte de 15 observaciones. El modelo genera una proyecci√≥n que mantiene el nivel actual del precio con ligeras variaciones y con una incertidumbre creciente en el tiempo, lo cual es coherente con la naturaleza estoc√°stica de una serie financiera: a medida que se pronostican pasos m√°s lejanos, el rango de valores posibles se ampl√≠a.

**Tabla Comparativa**

```{r t-comparativa}
tabla_comparativa_GLTR <- data.frame(
  D√≠a = 1:length(Prueba_GLTR),
  Fecha = format(index(Prueba_GLTR), "%Y-%m-%d"),
  Real = round(as.numeric(Prueba_GLTR), 2),
  Pron√≥stico = round(as.numeric(pronostico_GLTR$mean), 2),
  Error_USD = round(as.numeric(Prueba_GLTR) - as.numeric(pronostico_GLTR$mean), 2),
  Error_Pct = round(((as.numeric(Prueba_GLTR) - as.numeric(pronostico_GLTR$mean)) / 
                       as.numeric(Prueba_GLTR)) * 100, 3)
)

kable(tabla_comparativa_GLTR[1:5, ], 
      caption = "Comparaci√≥n: Valores Reales vs Pron√≥sticos GLTR",
      align = c("c", "c", "c", "c", "c", "c")) %>%
  kable_styling(bootstrap_options = c("striped", "hover", "condensed"),
                full_width = FALSE,
                position = "center")
```

**Gr√°fico: Predicho vs Real**

```{r predicho-vs-real}
fechas_pronostico_GLTR <- index(Prueba_GLTR)

ggplot() +
  geom_line(data = data.frame(Fecha = index(Entrenamiento_GLTR), 
                              Precio = as.numeric(Entrenamiento_GLTR)),
            aes(x = Fecha, y = Precio), color = 'black', alpha = 0.6) +
  geom_line(data = data.frame(Fecha = index(Prueba_GLTR), 
                              Precio = as.numeric(Prueba_GLTR)),
            aes(x = Fecha, y = Precio), color = gltr_pal$negative, linewidth = 1.2) +
  geom_line(data = data.frame(Fecha = fechas_pronostico_GLTR,
                              Precio = as.numeric(pronostico_GLTR$mean)),
            aes(x = Fecha, y = Precio), color = gltr_pal$tertiary, linewidth = 1) +
  labs(
    title = "GLTR: Pron√≥stico vs Real",
    subtitle = paste0("Negro=Entrenamiento | Rojo=Real | Azul=Pron√≥stico ", Modelo_GLTR_auto),
    x = "Fecha", 
    y = "Precio USD"
  ) +
  theme_minimal()
```

**M√©tricas de Desempe√±o**

```{r metricas-finales}
MAE_GLTR <- mean(abs(tabla_comparativa_GLTR$Error_USD))
RMSE_GLTR <- sqrt(mean(tabla_comparativa_GLTR$Error_USD^2))
MAPE_GLTR <- mean(abs(tabla_comparativa_GLTR$Error_Pct))

tabla_metricas_finales <- data.frame(
  M√©trica = c("MAE (Error Absoluto Medio)", 
              "RMSE (Ra√≠z del Error Cuadr√°tico Medio)", 
              "MAPE (Error Porcentual Absoluto Medio)"),
  Valor = c(round(MAE_GLTR, 4), 
            round(RMSE_GLTR, 4), 
            paste0(round(MAPE_GLTR, 2), "%")),
  Interpretaci√≥n = c("Promedio de errores en USD", 
                     "Penaliza errores grandes", 
                     "Error promedio en porcentaje")
)

kable(tabla_metricas_finales, 
      caption = "M√©tricas de Desempe√±o del Pron√≥stico - Datos de Prueba",
      align = c("l", "c", "l")) %>%
  kable_styling(bootstrap_options = c("striped", "hover", "condensed"),
                full_width = FALSE,
                position = "center")
```


# Conclusiones

**Hallazgos Principales**

El an√°lisis ARIMA realizado permite caracterizar la serie temporal mediante la identificaci√≥n de su estructura de autocorrelaci√≥n, estacionariedad y componentes de tendencia y estacionalidad. Los resultados obtenidos proporcionan una base s√≥lida para la generaci√≥n de pron√≥sticos confiables.


**Implicaciones y Recomendaciones**

Los pron√≥sticos obtenidos pueden utilizarse para:

- Planificaci√≥n estrat√©gica a corto y mediano plazo
- Asignaci√≥n eficiente de recursos
- Identificaci√≥n de desviaciones significativas
- Apoyo en la toma de decisiones basada en evidencia
- Los pron√≥sticos pierden precisi√≥n en horizontes muy lejanos
- Cambios estructurales no capturados afectar√≠an la predicci√≥n
- La calidad de los datos es fundamental para la confiabilidad
- Validaci√≥n con datos nuevos es recomendada


# Referencias Bibliogr√°ficas

Box, G. E. P., Jenkins, G. M., Reinsel, G. C., & Ljung, G. M. (2016). Time series analysis: Forecasting and control (5th ed.). Wiley.

Brockwell, P. J., & Davis, R. A. (2016). Introduction to time series and forecasting (3rd ed.). Springer.

DataCamp. (2024). Time series analysis in Python.
[Texto visible](https://www.datacamp.com/tutorial/time-series-analysis-python)

finance.yahoo.com. (2025). abrdn Physical Precious Metals Basket Shares ETF (GLTR) ‚Äì Performance. 
[Texto visible](https://finance.yahoo.com/quote/GLTR/performance/
gainesvillecoins.com) (2025).

Gold $3269, platinum surges 47%: Bullion brief July 2025. 
[Texto visible](https://gainesvillecoins.com/blog/gold-3269-platinum-surges-47-bullion-brief-july-2025)
goldavenue.com. (2025). Gold price forecast 2025: Will precious metals prices go up. 
[Texto visible](https://www.goldavenue.com/gold-price-forecast-2025)

Hyndman, R. J., & Athanasopoulos, G. (2021). Forecasting: Principles and practice (3rd ed.). OTexts. 
[Texto visible](https://otexts.com/fpp3/)

NumXL. (2024). Box-Jenkins methodology. 
[Texto visible](https://www.numxl.com/support/docs/reference_manual/arima/box-jenkins-methodology)

repec.org. (n.d.). Geopolitical shocks and commodity market dynamics ‚Äì NBER Working Papers. 
[Texto visible](https://repec.org/)

sciencedirect.com. (2024). Precious metals and currency markets during the Russia-Ukraine war. 
[Texto visible](https://www.sciencedirect.com/science/article/pii/S1544612324000085)

seekingalpha.com. (2025). Precious metals in 2025: GLTR for a diversified approach.
[Texto visible](https://seekingalpha.com/article/4747357-precious-metals-in-2025-gltr-for-a-diversified-approach)

Shumway, R. H., & Stoffer, D. S. (2017). Time series analysis and its applications: With R examples (4th ed.). Springer.
stockanalysis.com. (2025). abrdn Physical Precious Metals Basket Shares ETF (GLTR). 
[Texto visible](https://stockanalysis.com/etf/gltr/)

tradingview.com. (2025). An√°lisis ETF GLTR ‚Äì TradingView. 
[Texto visible](https://es.tradingview.com/symbols/BMV-GLTR/analysis/)
 
Wikipedia. (2014). Ljung-Box test. 
[Texto visible](https://en.wikipedia.org/wiki/Ljung%E2%80%93Box_test)

worldbank.org. (2022). Commodity markets outlook, April 2022. 
[Texto visible](https://www.worldbank.org/en/research/commodity-markets)




```{=html}
<div class="footer">
<strong>Universidad del Valle</strong> | <em>Facultad de Ingenier√≠a</em> | Gesti√≥n de Datos<br>
Profesor: Orlando Joaqui Barandica | Series de Tiempo y Pron√≥sticos | 2024-2025<br>
<strong>Documento generado:</strong> `r format(Sys.Date(), '%d de %B de %Y')`
</div>
```
